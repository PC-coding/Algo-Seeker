[{"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/index.js":"1","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/App.js":"2","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/reportWebVitals.js":"3","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/PathfindingVisualizer.js":"4","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/Node/Node.js":"5","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/dijkstra/djikstra.js":"6","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS.jsx":"7","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS2.js":"8","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BubbleSort/BubbleSort.js":"9","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/QuickSort/QuickSort.js":"10","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Router.js":"11","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Navbar.js":"12","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/A*Star/A_star.js":"13","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Traveling_Salesperson/TravelingSalesperson.js":"14","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/HomePage/HomePage.js":"15"},{"size":500,"mtime":1607018973582,"results":"16","hashOfConfig":"17"},{"size":396,"mtime":1607891567660,"results":"18","hashOfConfig":"17"},{"size":362,"mtime":1607018973582,"results":"19","hashOfConfig":"17"},{"size":6359,"mtime":1608919647625,"results":"20","hashOfConfig":"17"},{"size":689,"mtime":1607735611637,"results":"21","hashOfConfig":"17"},{"size":2464,"mtime":1607735320937,"results":"22","hashOfConfig":"17"},{"size":18366,"mtime":1608770245343,"results":"23","hashOfConfig":"17"},{"size":18483,"mtime":1608770093864,"results":"24","hashOfConfig":"17"},{"size":3156,"mtime":1609037477057,"results":"25","hashOfConfig":"17"},{"size":4603,"mtime":1609037428435,"results":"26","hashOfConfig":"17"},{"size":1299,"mtime":1608055279666,"results":"27","hashOfConfig":"17"},{"size":1812,"mtime":1608602825170,"results":"28","hashOfConfig":"17"},{"size":9529,"mtime":1608611699561,"results":"29","hashOfConfig":"17"},{"size":7146,"mtime":1608612226568,"results":"30","hashOfConfig":"17"},{"size":3181,"mtime":1609036973411,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},"zofrmq",{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"34"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48","usedDeprecatedRules":"34"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":1,"source":"51","usedDeprecatedRules":"34"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"54","messages":"55","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"56","messages":"57","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"34"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"34"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"34"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"34"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/index.js",[],["70","71"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/App.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/reportWebVitals.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/PathfindingVisualizer.js",["72","73","74","75","76","77","78","79","80"],"import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"../dijkstra/djikstra\";\nimport {\n  Container,\n  Divider,\n  Dropdown,\n  Grid,\n  Header,\n  Image,\n  List,\n  Menu,\n  Button,\n  Segment\n} from \"semantic-ui-react\";\n\n\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 10;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 40;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [],\n      mouseIsPressed: false\n    };\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({ grid });\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({ grid: newGrid, mouseIsPressed: true });\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({ grid: newGrid });\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 50 * i);\n    }\n  }\n\n  visualizeDijkstra() {\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  clearPath() {\n    this.setState({ grid: [] });\n    const grid = getInitialGrid();\n    this.setState({ grid });\n  }\n\n  resetSketch() {\n    window.location.reload();\n  }\n\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n\n    return (\n      <section id=\"dijkstraSec\">\n\n        <div id=\"dijkstraTitle\">\n  Dijkstra's Algorithm\n</div> <b></b>\n\n<div className=\"dijkstraDescription\">\n    <b id='bold'>What is it?:</b> <br />\n    Dijkstra's Algorithm is an algorithm for finding the shortest paths between nodes in a graph.<br />\n    It generates a shortest path tree with given source which guarantees the shortest path.<br />\n    <br/>\n<b id=\"bold\">How to use: </b> <br />\n    Create walls by clicking and dragging over the grid. <br />\n    Hit visualize to see Dijkstra's Algorithm select the shortest path!  <br />\n    <br/>\n<b id=\"bold\"> How it works: </b> <br />The <b>start</b> node and <b>end</b> node are marked on left and right respectively. <br />\n    Find distance to all nodes from start, all distances=infinity except start node to begin <br />\n<b id=\"bold\">1.</b> Pick the closest node to visit, which is start node. <br />\n  <b id=\"bold\">2.</b> Update neighboring nodes, set their distance to current distance + 1.<br></br>\n  <b id=\"bold\">3.</b> Mark start node visited. Select next closest node.\n  <br />\n  <b id=\"bold\">4.</b> Pick one of the 4 neighbors and repeat.<br></br><br></br>\n<b id=\"bold\">Note: </b>The most efficient way to keep track of the closest unvisited node is by using a Min Heap.<br></br>\n  Since the amount of nodes is so few here, we opt for using an array of unvisited nodes and<br></br>\n   sort the nodes with each pass. The nodes are animated in the order that they are visited.\n\n\n</div>\n\n          <Button\n              style={{ marginRight: 16 }}\n              onClick={() => this.clearPath()}\n            >\n              Clear Path\n            </Button>\n\n            <Button\n              color=\"blue\"\n              style={{ marginRight: 16 }}\n              onClick={() => this.visualizeDijkstra()}>\n              Visualize Algorithm\n            </Button>\n\n\n\n\n        <Button onClick={() => this.resetSketch()}>\n          Reset Board\n        </Button>\n\n        <div className=\"dijkstraGrid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isFinish, isStart, isWall } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </section>\n    );\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/Node/Node.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/dijkstra/djikstra.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS.jsx",["81","82","83","84","85","86","87","88","89","90","91","92"],"import React, {Component} from 'react';\n\nvar DUMMY_OBSTACLES = \n    ['{\"q\":6,\"r\":9,\"s\":-15}', '{\"q\":7,\"r\":8,\"s\":-15}', \n    '{\"q\":7,\"r\":7,\"s\":-14}', '{\"q\":8,\"r\":6,\"s\":-14}', \n    '{\"q\":8,\"r\":5,\"s\":-13}', '{\"q\":9,\"r\":4,\"s\":-13}', \n    '{\"q\":5,\"r\":9,\"s\":-14}', '{\"q\":4,\"r\":9,\"s\":-13}', \n    '{\"q\":3,\"r\":9,\"s\":-12}', \n    '{\"q\":2,\"r\":9,\"s\":-11}', '{\"q\":1,\"r\":9,\"s\":-10}', \n    '{\"q\":0,\"r\":9,\"s\":-9}', '{\"q\":-1,\"r\":9,\"s\":-8}', \n    '{\"q\":-2,\"r\":9,\"s\":-7}', '{\"q\":-3,\"r\":9,\"s\":-6}',\n    '{\"q\":-4,\"r\":9,\"s\":-5}', '{\"q\":-5,\"r\":9,\"s\":-4}', \n    '{\"q\":-6,\"r\":9,\"s\":-3}', '{\"q\":-7,\"r\":9,\"s\":-2}', \n    '{\"q\":-8,\"r\":9,\"s\":-1}', '{\"q\":-9,\"r\":9,\"s\":0}', \n    '{\"q\":-11,\"r\":9,\"s\":2}', '{\"q\":-10,\"r\":9,\"s\":1}',\n    '{\"q\":-12,\"r\":9,\"s\":3}', '{\"q\":-13,\"r\":9,\"s\":4}', \n    '{\"q\":-14,\"r\":9,\"s\":5}', '{\"q\":-15,\"r\":9,\"s\":6}', \n    '{\"q\":-15,\"r\":8,\"s\":7}', '{\"q\":-14,\"r\":7,\"s\":7}', \n    '{\"q\":-14,\"r\":6,\"s\":8}', '{\"q\":-13,\"r\":5,\"s\":8}',\n    '{\"q\":-13,\"r\":4,\"s\":9}', '{\"q\":-12,\"r\":3,\"s\":9}', \n    '{\"q\":-12,\"r\":2,\"s\":10}', '{\"q\":-11,\"r\":1,\"s\":10}', \n    '{\"q\":-11,\"r\":0,\"s\":11}', '{\"q\":-10,\"r\":-1,\"s\":11}', \n    '{\"q\":-10,\"r\":-2,\"s\":12}',\n    '{\"q\":-9,\"r\":-3,\"s\":12}', '{\"q\":-9,\"r\":-4,\"s\":13}', \n    '{\"q\":-8,\"r\":-5,\"s\":13}', '{\"q\":-8,\"r\":-6,\"s\":14}', \n    '{\"q\":-7,\"r\":-7,\"s\":14}', '{\"q\":-7,\"r\":-8,\"s\":15}', \n    '{\"q\":-6,\"r\":-9,\"s\":15}',\n    '{\"q\":-5,\"r\":-9,\"s\":14}', '{\"q\":-4,\"r\":-9,\"s\":13}', \n    '{\"q\":-3,\"r\":-9,\"s\":12}', '{\"q\":-2,\"r\":-9,\"s\":11}', \n    '{\"q\":-1,\"r\":-9,\"s\":10}', '{\"q\":0,\"r\":-9,\"s\":9}', \n    '{\"q\":1,\"r\":-9,\"s\":8}', '{\"q\":2,\"r\":-9,\"s\":7}',\n    '{\"q\":3,\"r\":-9,\"s\":6}', '{\"q\":4,\"r\":-9,\"s\":5}', \n    '{\"q\":5,\"r\":-9,\"s\":4}', '{\"q\":6,\"r\":-9,\"s\":3}', \n    '{\"q\":7,\"r\":-9,\"s\":2}', '{\"q\":8,\"r\":-9,\"s\":1}', \n    '{\"q\":9,\"r\":-9,\"s\":0}', '{\"q\":10,\"r\":-9,\"s\":-1}',\n    '{\"q\":11,\"r\":-9,\"s\":-2}', '{\"q\":12,\"r\":-9,\"s\":-3}', \n    '{\"q\":13,\"r\":-9,\"s\":-4}', '{\"q\":14,\"r\":-9,\"s\":-5}', \n    '{\"q\":15,\"r\":-9,\"s\":-6}', '{\"q\":15,\"r\":-8,\"s\":-7}', \n    '{\"q\":14,\"r\":-7,\"s\":-7}',\n    '{\"q\":14,\"r\":-6,\"s\":-8}', '{\"q\":13,\"r\":-5,\"s\":-8}', \n    '{\"q\":13,\"r\":-4,\"s\":-9}', '{\"q\":12,\"r\":-3,\"s\":-9}', \n    '{\"q\":12,\"r\":-2,\"s\":-10}', '{\"q\":11,\"r\":-1,\"s\":-10}', \n    '{\"q\":11,\"r\":0,\"s\":-11}',\n    '{\"q\":10,\"r\":1,\"s\":-11}', '{\"q\":10,\"r\":2,\"s\":-12}', \n    '{\"q\":9,\"r\":3,\"s\":-12}', '{\"q\":-2, \"r\":-8, \"s\":10}', \n    '{\"q\": -3, \"r\": -7, \"s\": 10}', '{\"q\": -4, \"r\": -6, \"s\": 10}', \n    '{\"q\": -5, \"r\": -5, \"s\": 10}',\n    '{\"q\": -6, \"r\": -4, \"s\": 10}', '{\"q\": -7, \"r\": -4, \"s\": 11}', \n    '{\"q\": 4, \"r\": -7, \"s\": 3}', '{\"q\": 3, \"r\": -6, \"s\": 3}', \n    '{\"q\": 2, \"r\": -5, \"s\": 3}',\n    '{\"q\": 1, \"r\": -4, \"s\": 3}',\n    '{\"q\": 2, \"r\": -4, \"s\": 2}',\n    '{\"q\": 3, \"r\": -4, \"s\": 1}',\n    '{\"q\": 4, \"r\": -4, \"s\": 0}',\n    '{\"q\": 9, \"r\": -3, \"s\": -6}',\n    '{\"q\": 10, \"r\": -3, \"s\": -7}',\n    '{\"q\": 8, \"r\": -2, \"s\": -6}',\n    '{\"q\": 7, \"r\": -2, \"s\": -5}',\n    '{\"q\": 4, \"r\": -2, \"s\": -2}',\n    '{\"q\": 4, \"r\": -1, \"s\": -3}',\n    '{\"q\": 4, \"r\": 0, \"s\": -4}',\n    '{\"q\": 4, \"r\": 1, \"s\": -5}',\n    '{\"q\": 3, \"r\": 2, \"s\": -5}',\n    '{\"q\": 2, \"r\": 3, \"s\": -5}',\n    '{\"q\": 1, \"r\": 4, \"s\": -5}',\n    '{\"q\": -0, \"r\": 5, \"s\": -5}',\n    '{\"q\": -1, \"r\": 6, \"s\": -5}',\n    '{\"q\": -2, \"r\": 7, \"s\": -5}',\n    '{\"q\": 4, \"r\": 5, \"s\": -9}',\n    '{\"q\": 4, \"r\": 6, \"s\": -10}',\n    '{\"q\": 5, \"r\": 6, \"s\": -11}',\n    '{\"q\": 5, \"r\": 7, \"s\": -12}',\n    '{\"q\": -5, \"r\": 7, \"s\": -2}',\n    '{\"q\": -5, \"r\": 8, \"s\": -3}',\n    '{\"q\": -5, \"r\": 6, \"s\": -1}',\n    '{\"q\": -5, \"r\": 5, \"s\": 0}',\n    '{\"q\": -4, \"r\": 4, \"s\": -0}',\n    '{\"q\": -3, \"r\": 3, \"s\": -0}',\n    '{\"q\": -5, \"r\": 3, \"s\": 2}',\n    '{\"q\": -6, \"r\": 4, \"s\": 2}',\n    '{\"q\": -4, \"r\": 2, \"s\": 2}',\n    '{\"q\": -4, \"r\": 1, \"s\": 3}',\n    '{\"q\": -7, \"r\": 4, \"s\": 3}',\n    '{\"q\": -8, \"r\": 4, \"s\": 4}',\n    '{\"q\": -9, \"r\": 4, \"s\": 5}',\n    '{\"q\": -10, \"r\": 4, \"s\": 6}',\n    '{\"q\": -11, \"r\": 4, \"s\": 7}',\n    '{\"q\": -12, \"r\": 4, \"s\": 8}',\n    '{\"q\": -6, \"r\": 1, \"s\": 5}',\n    '{\"q\": -6, \"r\": 0, \"s\": 6}',\n    '{\"q\": -6, \"r\": -1, \"s\": 7}',\n    '{\"q\": -6, \"r\": -2, \"s\": 8}',\n    '{\"q\": -2, \"r\": -1, \"s\": 3}',\n    '{\"q\": -2, \"r\": -2, \"s\": 4}']\n\n\n\n\nexport default class BreadthFirstSearch extends Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.handleClick = this.handleClick.bind(this);\n    this.handleExpandClick = this.handleExpandClick.bind(this);\n\n    this.state = {\n      hexSize: 20,\n      //position of the very middle hexagon (changes the numbers seen in hexagons)\n      //decreasing y moves hexagon(0,0,0) upwards, increasing x moves hexagon(0,0,0) to the right\n      hexOrigin: { x: 400, y: 300 },\n      currentHex: {q: 0, r: 0, s: 0, x: 0, y: 0},\n      playerPosition: {q: 0, r: 0, s: 0, x: 400, y: 300},\n      obstacles: DUMMY_OBSTACLES,\n      frontier: [],\n      //storing hexagons starting from playerPosition\n      cameFrom: {}\n    }\n  }\n  componentWillMount(){\n    let hexParametres = this.getHexParametres();\n    this.setState({\n      canvasSize: { canvasWidth: 800, canvasHeight: 600 },\n      hexParametres: hexParametres\n    })\n  }\n\n  componentDidMount(){\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    this.canvasHex.width = canvasWidth;\n    this.canvasHex.height = canvasHeight;\n    this.canvasInteraction.width = canvasWidth;\n    this.canvasInteraction.height = canvasHeight;\n    this.canvasView.width = canvasWidth;\n    this.canvasView.height = canvasHeight;\n    this.getCanvasPosition(this.canvasInteraction);\n    this.drawHex(this.canvasInteraction, this.Point(this.state.playerPosition.x, this.state.playerPosition.y), 1, \"grey\", \"red\", 0.2);\n    this.drawHexes();\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if(nextState.currentHex !== this.state.currentHex) {\n      const { q, r, s, x, y } = nextState.currentHex;\n      const { canvasWidth, canvasHeight } = this.state.canvasSize;\n      const ctx = this.canvasInteraction.getContext(\"2d\");\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n      let currentDistanceLine = nextState.currentDistanceLine;\n\n      for (let i = 0; i <= currentDistanceLine.length - 2; i++) {\n        if(i === 0) {\n          this.drawHex(this.canvasInteraction, this.Point(currentDistanceLine[i].x, currentDistanceLine[i].y), 1, \"black\", \"red\");\n        }else {\n          this.drawHex(this.canvasInteraction, this.Point(currentDistanceLine[i].x, currentDistanceLine[i].y), 1, \"black\", \"grey\");\n        }\n\n      }\n      nextState.obstacles.map((l)=>{\n        const { q, r, s } = JSON.parse(l);\n        const { x, y } = this.hexToPixel(this.Hex(q, r, s))\n        this.drawHex(this.canvasInteraction, this.Point(x, y), 1, \"black\", \"black\");\n\n      })\n      this.drawHex(this.canvasInteraction, this.Point(x, y), 1, \"black\", \"grey\");\n      return true;\n    }\n    if(nextState.cameFrom !== this.state.cameFrom) {\n      const { canvasWidth, canvasHeight } = this.state.canvasSize;\n      const ctx = this.canvasView.getContext(\"2d\");\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n      for(let l in nextState.cameFrom) {\n        const { q, r, s } = JSON.parse(l);\n        const { x, y } = this.hexToPixel(this.Hex(q, r));\n        this.drawHex(this.canvasView, this.Point(x, y), 1, \"black\", \"green\", 0.1);\n      }\n      return true;\n    }\n\n    return false;\n  }\n\n\n  drawHexes() {\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n    //calculate how many columns are on the left side\n    //hexOrigin is distance from coorindate x = 0 to hex0(middle hexagon)\n    const hexOrigin = this.state.hexOrigin;\n    //dividing the distance from the left side of border(x=0) by\n    //the width of a hexagon to calculate how many hexagons fit on left\n    let qLeftSide = Math.round(hexOrigin.x/horizDist);\n    //calculate how many hexagons will fit on the right\n    let qRightSide = Math.round((canvasWidth - hexOrigin.x)/horizDist);\n    let rTopSide = Math.round(hexOrigin.y/vertDist);\n    let rBottomSide = Math.round((canvasHeight - hexOrigin.y)/vertDist);\n    var p = 0;\n    //screenshot 1 - populates hexigons vertically (populates POSITIVE rows)\n    for(let r = 0; r <= rBottomSide; r++) {\n      if(r%2 === 0 && r !== 0) {\n        p++;\n      }\n      //populates hexigons horizontally in upper half (populates POSITIVE columns)\n      for(let q = -qLeftSide; q <= qRightSide; q++) {\n          const { x, y } = this.hexToPixel(this.Hex(q-p, r));\n          if((x > hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n            this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n            //passing in canvas and position of each hex(row, column)\n\n          }\n      }\n    }\n    var n = 0;\n    //screenshot 1 - populates hexigons vertically (populates NEGATIVE rows)\n    for(let r = -1; r >= -rTopSide; r--) {\n      if(r%2 !== 0) {\n        n++;\n      }\n      //populates hexigons horizontally in lower half (populates NEGATIVE columns)\n      for(let q = -qLeftSide; q <= qRightSide; q++) {\n          //adding integers to hexToPixel arguments shifts hexagons right\n          const { x, y } = this.hexToPixel(this.Hex(q+n, r));\n          if((x > hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n            this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n\n          }\n      }\n    }\n  }\n\n  //builds the individual hex shape\n  drawHex(canvasID, center, lineWidth, lineColor, fillColor) {\n    for(let i = 0; i <=5; i++) {\n      let start = this.getHexCornerCoord(center, i);\n      let end = this.getHexCornerCoord(center, i + 1);\n\n      this.fillHex(canvasID, center, fillColor);\n      this.drawLine(canvasID, start, end, lineWidth, lineColor);\n\n    }\n  }\n\n  //get the coordinates of the corner to draw the hex\n    getHexCornerCoord(center, i) {\n      var angle_deg = 60 * i + 30;\n      var angle_rad = Math.PI / 180 * angle_deg;\n      let x = center.x + this.state.hexSize * Math.cos(angle_rad);\n      let y = center.y + this.state.hexSize * Math.sin(angle_rad);\n      return this.Point(x, y);\n    }\n\n    Hex(q, r, s) {\n      return {q: q, r: r, s: s}\n    }\n\n    Point(x, y) {\n      return {x: x, y: y}\n    }\n\n//draws the line that shapes the hex\n  drawLine(canvasID, start, end, lineWidth, lineColor) {\n    const ctx = canvasID.getContext(\"2d\");\n    ctx.beginPath();\n    ctx.moveTo(start.x, start.y);\n    ctx.strokeStyle = lineColor;\n    ctx.lineWidth = lineWidth;\n    ctx.lineTo(end.x, end.y);\n    ctx.stroke();\n    ctx.closePath();\n  }\n\n  fillHex(canvasID, center, fillColor) {\n    let c0 = this.getHexCornerCoord(center, 0);\n    let c1 = this.getHexCornerCoord(center, 1);\n    let c2 = this.getHexCornerCoord(center, 2);\n    let c3 = this.getHexCornerCoord(center, 3);\n    let c4 = this.getHexCornerCoord(center, 4);\n    let c5 = this.getHexCornerCoord(center, 5);\n    const ctx = canvasID.getContext(\"2d\");\n    ctx.beginPath();\n    ctx.fillStyle = fillColor;\n    ctx.globalAlpha = 0.1;\n    ctx.moveTo(c0.x, c0.y);\n    ctx.lineTo(c1.x, c1.y);\n    ctx.lineTo(c2.x, c2.y);\n    ctx.lineTo(c3.x, c3.y);\n    ctx.lineTo(c4.x, c4.y);\n    ctx.lineTo(c5.x, c5.y);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n//prints the coordinates inside of the hexagons\n  drawHexCoordinates(canvasID, center, h) {\n    const ctx = canvasID.getContext(\"2d\");\n    ctx.fillText(h.q, center.x+6, center.y);\n    ctx.fillText(h.r, center.x-3, center.y+15);\n    ctx.fillText(h.s, center.x-12, center.y);\n  }\n\n\n\n  getHexParametres() {\n    let hexHeight = this.state.hexSize * 2;\n    let hexWidth = Math.sqrt(3)/2 * hexHeight;\n    //vertical distance between hexigons in each row\n    let vertDist = hexHeight * 3/4;\n    let horizDist = hexWidth;\n    return { hexWidth, hexHeight, vertDist, horizDist }\n  }\n\n  hexToPixel(h) {\n    //can change where the bundle of hexes originates on the whole grid\n    let hexOrigin = this.state.hexOrigin;\n    let x = this.state.hexSize * Math.sqrt(3) * (h.q + h.r/2) + hexOrigin.x;\n    let y = this.state.hexSize * 3/2 * h.r + hexOrigin.y;\n    return this.Point(x, y)\n  }\n\n  pixelToHex(p) {\n    let size = this.state.hexSize;\n    let origin = this.state.hexOrigin;\n    let q = ((p.x - origin.x) * Math.sqrt(3)/3 - (p.y - origin.y) / 3) / size\n    let r = (p.y - origin.y) * 2/3 / size\n    return this.Hex(q, r, -q - r);\n  }\n\n  getDistanceLine(hexA, hexB) {\n    let dist = this.cubeDistance(hexA, hexB);\n    var arr = [];\n    for(let i = 0; i <= dist; i++) {\n     let center = this.hexToPixel(this.cubeRound(this.cubeLinearInt(hexA, hexB, 1.0 / dist * i)));\n     arr = [].concat(arr, center);\n    }\n    this.setState({\n      currentDistanceLine: arr\n    })\n  }\n\n\n\n  cubeDirection(direction) {\n    const cubeDirections = [this.Hex(1, 0, -1), this.Hex(1, -1, 0), this.Hex(0, -1, 1),\n    this.Hex(-1, 0, 1), this.Hex(-1, 1, 0), this.Hex(0, 1, -1)];\n    return cubeDirections[direction];\n  }\n\n  cubeLinearInt(hexA, hexB, t) {\n    return this.Hex(this.linearInt(hexA.q, hexB.q, t), this.linearInt(hexA.r, hexB.r, t),\n    this.linearInt(hexA.s, hexB.s, t));\n  }\n\n  linearInt(a, b, t) {\n    return (a + (b - a) * t)\n  }\n\n  cubeAdd(a, b) {\n    return this.Hex(a.q + b.q, a.r + b.r, a.s + b.s);\n  }\n\n  cubeSubstract(hexA, hexB) {\n    return this.Hex(hexA.q - hexB.q, hexA.r - hexB.r, hexA.s - hexB.s);\n  }\n\n  getCubeNeighbor(h, direction) {\n    return this.cubeAdd(h, this.cubeDirection(direction));\n  }\n\n  getNeighbors(h) {\n    var arr = [];\n    for(let i = 0; i <=5; i++) {\n      const { q, r, s } = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n      arr.push(this.Hex(q, r, s));\n    }\n    return arr;\n  }\n\n\n\n  cubeRound(cube) {\n    var rx = Math.round(cube.q)\n    var ry = Math.round(cube.r)\n    var rz = Math.round(cube.s)\n    var x_diff = Math.abs(rx - cube.q)\n    var y_diff = Math.abs(ry - cube.r)\n    var z_diff = Math.abs(rz - cube.s)\n    if(x_diff > y_diff && x_diff > z_diff) {\n      rx = -ry-rz\n    }\n    else if(y_diff > z_diff) {\n      ry = -rx-rz\n    }\n    else{\n      rz = -rx-ry\n    }\n    return this.Hex(rx, ry, rz)\n  }\n\n\n\n  cubeDistance(hexA, hexB) {\n    const { q, r, s } = this.cubeSubstract(hexA, hexB);\n    return (Math.abs(q) + Math.abs(r) + Math.abs(s)) / 2;\n  }\n\n\n  drawNeighbors(h) {\n    for(let i = 0; i <= 5; i++) {\n      const { q, r, s } = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n      const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n      this.drawHex(this.canvasInteraction, this.Point(x, y), \"red\", 2);\n    }\n  }\n\n\n    getCanvasPosition(canvasID) {\n      let rect = canvasID.getBoundingClientRect();\n      this.setState({\n         canvasPosition: { left:rect.left, right: rect.right, top: rect.top, bottom: rect.bottom }\n      })\n    }\n\n  handleMouseMove(e) {\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n    //const { left, right, top, bottom } = this.state.canvasPosition;\n    //changing the number at the end affects result exponentially\n    var canvasPos = document.getElementById(\"canv3\");\n    let rect = canvasPos.getBoundingClientRect();\n    let offsetX = e.pageX - rect.left;\n    let offsetY = (e.pageY - (window.pageYOffset + rect.top));\n\n\n\n\n\n\n    const { q, r, s } = this.cubeRound(this.pixelToHex(this.Point(offsetX, offsetY)));\n    const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n\n   let playerPosition = this.state.playerPosition;\n\n\n    this.getDistanceLine(this.Hex(0,0,0), this.Hex(q,r,s));\n\n    if((x > hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n      this.setState({\n        currentHex: {q, r, s, x, y}\n      })\n    }\n\n  }\n\n  handleClick() {\n    this.addObstacles();\n  }\n\n  addObstacles() {\n    const { q, r, s } = this.state.currentHex;\n    let obstacles = this.state.obstacles;\n    if(!obstacles.includes(JSON.stringify(this.Hex(q, r, s)))) {\n      obstacles = [].concat(obstacles, JSON.stringify(this.Hex(q, r, s)))\n    } else {\n      obstacles.map((l,i) => {\n        if(l === JSON.stringify(this.Hex(q, r, s))) {\n          obstacles = obstacles.slice(0, i).concat(obstacles.slice(i+1));\n        }\n      })\n    }\n    console.log({\"q\":q, \"r\":r, \"s\":s})\n    this.setState({\n      obstacles: obstacles\n    })\n  }\n\n  handleExpandClick() {\n    var frontier = this.state.frontier;\n    var cameFrom = this.state.cameFrom;\n    if(frontier == 0) {\n      frontier.push(this.Hex(0,0,0));\n      cameFrom[JSON.stringify(this.Hex(0,0,0))] = JSON.stringify(null);\n    }\n    let n = 0;\n    while(n < 1) {\n      var current = frontier.shift();\n      let arr = this.getNeighbors(current);\n      arr.map((l) => {\n        if(!cameFrom.hasOwnProperty(JSON.stringify(l)) && !this.state.obstacles.includes(JSON.stringify(l))) {\n          frontier.push(l);\n          cameFrom[JSON.stringify(l)] = JSON.stringify(current);\n        }\n      })\n      n++\n    }\n    cameFrom = Object.assign({}, cameFrom);\n    this.setState({\n      cameFrom: cameFrom\n    })\n  }\n\n  resetSketch() {\n  window.location.reload();\n  }\n\n\nrender() {\n    return (\n      <section id=\"BFS\">\n        <div className=\"description25\">\n        <b id='bold'>Real World Application:</b><br/>\n        - The BFS algorithm is taught as a common algorithm to computer science students.<br/>\n        - It can be used to solve multiple graph theory problems.<br/>\n        <b id=\"bold\">How to use:</b> Hit expand to see Breadth First Search carried out starting\n          from the middle node.<br/>\n\n        </div>\n\n          <button\n              className=\"reset1\"\n              onClick={ this.resetSketch }\n              style= {{ textAlign: \"center\" }}\n            >\n              Reset\n            </button>\n\n            <button\n              className=\"expandButton1\"\n              color=\"blue\"\n              style={{textAlign: \"center\"}}\n              onClick={this.handleExpandClick}>\n              Expand\n            </button>\n\n            <br></br>\n        <canvas id=\"canv4\" ref={canvasHex => this.canvasHex = canvasHex }> </canvas>\n        <canvas id=\"canv3\" ref={canvasCoordinates => this.canvasCoordinates = canvasCoordinates }> </canvas>\n        <canvas id=\"canv2\" ref={canvasView => this.canvasView = canvasView }> </canvas>\n        <canvas id=\"canv1\" ref={canvasInteraction => this.canvasInteraction = canvasInteraction} onMouseMove = {this.handleMouseMove} onClick = {this.handleClick}> </canvas>\n    </section>\n    )\n  }\n}","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS2.js",["93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113"],"import React, {Component} from 'react';\n\nvar DUMMY_OBSTACLES = ['{\"q\":4,\"r\":-2,\"s\":-2}', \n'{\"q\":4,\"r\":-1,\"s\":-3}', '{\"q\":4,\"r\":0,\"s\":-4}', \n'{\"q\":4,\"r\":1,\"s\":-5}', '{\"q\":3,\"r\":2,\"s\":-5}', \n'{\"q\":2,\"r\":3,\"s\":-5}', '{\"q\":1,\"r\":4,\"s\":-5}', \n'{\"q\":0,\"r\":5,\"s\":-5}', '{\"q\":-1,\"r\":6,\"s\":-5}', \n'{\"q\":-2,\"r\":7,\"s\":-5}', '{\"q\":4,\"r\":-4,\"s\":0}', \n'{\"q\":3,\"r\":-4,\"s\":1}', '{\"q\":2,\"r\":-4,\"s\":2}', \n'{\"q\":1,\"r\":-4,\"s\":3}', '{\"q\":2,\"r\":-5,\"s\":3}', \n'{\"q\":3,\"r\":-6,\"s\":3}', '{\"q\":4,\"r\":-7,\"s\":3}', \n'{\"q\":5,\"r\":-9,\"s\":4}', '{\"q\":6,\"r\":-9,\"s\":3}', \n'{\"q\":7,\"r\":-9,\"s\":2}', '{\"q\":8,\"r\":-9,\"s\":1}', \n'{\"q\":9,\"r\":-9,\"s\":0}', '{\"q\":10,\"r\":-9,\"s\":-1}', \n'{\"q\":11,\"r\":-9,\"s\":-2}', '{\"q\":12,\"r\":-9,\"s\":-3}', \n'{\"q\":13,\"r\":-9,\"s\":-4}', '{\"q\":14,\"r\":-9,\"s\":-5}', \n'{\"q\":15,\"r\":-9,\"s\":-6}', '{\"q\":15,\"r\":-8,\"s\":-7}', \n'{\"q\":14,\"r\":-7,\"s\":-7}', '{\"q\":14,\"r\":-6,\"s\":-8}', \n'{\"q\":13,\"r\":-5,\"s\":-8}', '{\"q\":13,\"r\":-4,\"s\":-9}', \n'{\"q\":12,\"r\":-3,\"s\":-9}', '{\"q\":12,\"r\":-2,\"s\":-10}', \n'{\"q\":11,\"r\":-1,\"s\":-10}', '{\"q\":11,\"r\":0,\"s\":-11}', \n'{\"q\":10,\"r\":1,\"s\":-11}', '{\"q\":10,\"r\":2,\"s\":-12}', \n'{\"q\":9,\"r\":3,\"s\":-12}', '{\"q\":9,\"r\":4,\"s\":-13}', \n'{\"q\":8,\"r\":5,\"s\":-13}', '{\"q\":8,\"r\":6,\"s\":-14}', \n'{\"q\":7,\"r\":7,\"s\":-14}', '{\"q\":7,\"r\":8,\"s\":-15}', \n'{\"q\":6,\"r\":9,\"s\":-15}', '{\"q\":5,\"r\":9,\"s\":-14}', \n'{\"q\":4,\"r\":9,\"s\":-13}', '{\"q\":3,\"r\":9,\"s\":-12}', \n'{\"q\":2,\"r\":9,\"s\":-11}', '{\"q\":1,\"r\":9,\"s\":-10}', \n'{\"q\":0,\"r\":9,\"s\":-9}', '{\"q\":-1,\"r\":9,\"s\":-8}', \n'{\"q\":-2,\"r\":9,\"s\":-7}', '{\"q\":-3,\"r\":9,\"s\":-6}', \n'{\"q\":-4,\"r\":9,\"s\":-5}', '{\"q\":-5,\"r\":9,\"s\":-4}', \n'{\"q\":-5,\"r\":8,\"s\":-3}', '{\"q\":-5,\"r\":7,\"s\":-2}', \n'{\"q\":-5,\"r\":6,\"s\":-1}', '{\"q\":-5,\"r\":5,\"s\":0}', \n'{\"q\":-4,\"r\":4,\"s\":0}', '{\"q\":-3,\"r\":3,\"s\":0}', \n'{\"q\":-2,\"r\":-1,\"s\":3}', '{\"q\":-2,\"r\":-2,\"s\":4}', \n'{\"q\":-4,\"r\":1,\"s\":3}', '{\"q\":-4,\"r\":2,\"s\":2}', \n'{\"q\":-5,\"r\":3,\"s\":2}', '{\"q\":-7,\"r\":4,\"s\":3}', \n'{\"q\":-6,\"r\":4,\"s\":2}', '{\"q\":-8,\"r\":4,\"s\":4}', \n'{\"q\":-9,\"r\":4,\"s\":5}', '{\"q\":-10,\"r\":4,\"s\":6}', \n'{\"q\":-11,\"r\":4,\"s\":7}', '{\"q\":-12,\"r\":4,\"s\":8}', \n'{\"q\":-12,\"r\":2,\"s\":10}', '{\"q\":-12,\"r\":3,\"s\":9}', \n'{\"q\":-13,\"r\":4,\"s\":9}', '{\"q\":-13,\"r\":5,\"s\":8}', \n'{\"q\":-14,\"r\":6,\"s\":8}', '{\"q\":-14,\"r\":7,\"s\":7}', \n'{\"q\":-15,\"r\":8,\"s\":7}', '{\"q\":-15,\"r\":9,\"s\":6}', \n'{\"q\":-14,\"r\":9,\"s\":5}', '{\"q\":-13,\"r\":9,\"s\":4}', \n'{\"q\":-12,\"r\":9,\"s\":3}', '{\"q\":-11,\"r\":9,\"s\":2}', \n'{\"q\":-10,\"r\":9,\"s\":1}', '{\"q\":-9,\"r\":9,\"s\":0}', \n'{\"q\":-8,\"r\":9,\"s\":-1}', '{\"q\":-7,\"r\":9,\"s\":-2}', \n'{\"q\":-6,\"r\":9,\"s\":-3}', '{\"q\":-11,\"r\":1,\"s\":10}', \n'{\"q\":-11,\"r\":0,\"s\":11}', '{\"q\":-10,\"r\":-1,\"s\":11}', \n'{\"q\":-10,\"r\":-2,\"s\":12}', '{\"q\":-9,\"r\":-3,\"s\":12}', \n'{\"q\":-9,\"r\":-4,\"s\":13}', '{\"q\":-8,\"r\":-5,\"s\":13}', \n'{\"q\":-8,\"r\":-6,\"s\":14}', '{\"q\":-7,\"r\":-7,\"s\":14}', \n'{\"q\":-7,\"r\":-8,\"s\":15}', '{\"q\":-6,\"r\":-9,\"s\":15}', \n'{\"q\":-5,\"r\":-9,\"s\":14}', '{\"q\":-4,\"r\":-9,\"s\":13}', \n'{\"q\":-3,\"r\":-9,\"s\":12}', '{\"q\":-2,\"r\":-9,\"s\":11}', \n'{\"q\":-1,\"r\":-9,\"s\":10}', '{\"q\":0,\"r\":-9,\"s\":9}', \n'{\"q\":1,\"r\":-9,\"s\":8}', '{\"q\":2,\"r\":-9,\"s\":7}', \n'{\"q\":3,\"r\":-9,\"s\":6}', '{\"q\":4,\"r\":-9,\"s\":5}', \n'{\"q\":-2,\"r\":-8,\"s\":10}', '{\"q\":-3,\"r\":-7,\"s\":10}', \n'{\"q\":-4,\"r\":-6,\"s\":10}', '{\"q\":-5,\"r\":-5,\"s\":10}', \n'{\"q\":-6,\"r\":-4,\"s\":10}', '{\"q\":-7,\"r\":-4,\"s\":11}', \n'{\"q\":-6,\"r\":-2,\"s\":8}', '{\"q\":-6,\"r\":-1,\"s\":7}', \n'{\"q\":-6,\"r\":0,\"s\":6}', '{\"q\":-6,\"r\":1,\"s\":5}', \n'{\"q\":7,\"r\":-2,\"s\":-5}', '{\"q\":8,\"r\":-2,\"s\":-6}', \n'{\"q\":9,\"r\":-3,\"s\":-6}', '{\"q\":10,\"r\":-3,\"s\":-7}', \n'{\"q\":4,\"r\":5,\"s\":-9}', '{\"q\":4,\"r\":6,\"s\":-10}', \n'{\"q\":5,\"r\":6,\"s\":-11}', '{\"q\":5,\"r\":7,\"s\":-12}']\n\n\nexport default class BFSExtra extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.handleClick = this.handleClick.bind(this);\n    //possibly but this.breadthFirstSearch = this.breadthfirstsearch.bind(this)\n\n\n    this.state = {\n      hexSize: 20,\n      //position of the very middle hexagon (changes the numbers seen in hexagons)\n      //decreasing y moves hexagon(0,0,0) upwards, increasing x moves hexagon(0,0,0) to the right\n      hexOrigin: { x: 400, y: 300 },\n      currentHex: {q: 0, r: 0, s: 0, x: 0, y: 0},\n      playerPosition: { q: 0, r: 0, s: 0 },\n      obstacles: DUMMY_OBSTACLES,\n      cameFrom: {},\n      hexPathMap: [],\n      path: []\n    }\n  }\n  componentWillMount(){\n    let hexParametres =  this.getHexParametres();\n    this.setState({\n      canvasSize: { canvasWidth: 800, canvasHeight: 600 },\n      hexParametres: hexParametres\n    })\n  }\n\n  componentDidMount(){\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    this.canvasHex.width = canvasWidth;\n    this.canvasHex.height = canvasHeight;\n    this.canvasInteraction.width = canvasWidth;\n    this.canvasInteraction.height = canvasHeight;\n    this.canvasView.width = canvasWidth;\n    this.canvasView.height = canvasHeight;\n    this.getCanvasPosition(this.canvasInteraction);\n    this.drawHex(this.canvasInteraction, this.Point(this.state.playerPosition.x, this.state.playerPosition.y), 1, \"grey\", \"red\", 0.2);\n    this.drawHexes();\n    this.drawObstacles();\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if(nextState.currentHex !== this.state.currentHex) {\n  const { q, r, s, x, y } = nextState.currentHex;\n  const { canvasWidth, canvasHeight } = this.state.canvasSize;\n  const ctx = this.canvasInteraction.getContext(\"2d\");\n  ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n  /*this.drawNeighbors(this.Hex(q, r, s));*/\n  this.drawPath();\n  return true;\n}\n  if(nextState.cameFrom !== this.state.cameFrom) {\n  const { canvasWidth, canvasHeight } = this.state.canvasSize;\n  const ctx = this.canvasView.getContext(\"2d\");\n  ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n  for (let l in nextState.cameFrom) {\n    const { q, r, s } = JSON.parse(l);\n    const { x, y } = this.hexToPixel(this.Hex(q, r));\n    this.drawHex(this.canvasView, this.Point(x, y), 1, \"black\", \"green\", 0.1);\n    var from = JSON.parse(nextState.cameFrom[l]);\n    var fromCoord = this.hexToPixel(this.Hex(from.q, from.r));\n    this.drawArrow(fromCoord.x, fromCoord.y, x, y);\n  }\n  return true;\n  }\n  return false;\n  }\n\n\n  drawHexes() {\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n  const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n  const hexOrigin = this.state.hexOrigin;\n  let qLeftSide = Math.round(hexOrigin.x/horizDist);\n  let qRightSide = Math.round((canvasWidth - hexOrigin.x)/horizDist);\n  let rTopSide = Math.round(hexOrigin.y/vertDist);\n  let rBottomSide = Math.round((canvasHeight - hexOrigin.y)/vertDist);\n  var hexPathMap = [];\n  var p = 0;\n  for (let r = 0; r <= rBottomSide; r++) {\n    if(r%2 == 0 && r !==0) {\n      p++;\n    }\n    for (let q = -qLeftSide; q <= qRightSide; q++) {\n        const { x, y } = this.hexToPixel(this.Hex(q-p, r));\n        if ((x >hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n          this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n          /*this.drawHexCoordinates(this.canvasHex, this.Point(x,y), this.Hex(q-p, r, -(q - p) - r));*/\n          var bottomH = JSON.stringify(this.Hex(q-p, r, -(q - p) - r));\n          if(!this.state.obstacles.includes(bottomH)) {\n            hexPathMap.push(bottomH);\n          }\n        }\n    }\n  }\nvar n = 0;\n  for (let r = -1; r >= -rTopSide; r--) {\n    if(r%2 !== 0) {\n      n++;\n    }\n    for (let q = -qLeftSide; q <= qRightSide; q++) {\n        const { x, y } = this.hexToPixel(this.Hex(q+n, r));\n          if ((x >hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n        this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n        /*this.drawHexCoordinates(this.canvasHex, this.Point(x,y), this.Hex(q+n, r, - (q + n) - r));*/\n        var topH = JSON.stringify(this.Hex(q+n, r, - (q + n) - r));\n        if(!this.state.obstacles.includes(topH)) {\n          hexPathMap.push(topH);\n        }\n      }\n    }\n  }\n  hexPathMap = [].concat(hexPathMap);\n  this.setState(\n    {hexPathMap: hexPathMap},\n    this.breadthFirstSearchCallback = () => this.breadthFirstSearch(this.state.playerPosition)\n  )\n  }\n\n  //builds the individual hex shape\n  drawHex(canvasID, center, lineWidth, lineColor, fillColor) {\n  for (let i = 0; i <= 5; i++) {\n    let start = this.getHexCornerCoord(center, i);\n    let end = this.getHexCornerCoord(center, i + 1);\n    this.fillHex(canvasID, center, fillColor);\n    this.drawLine(canvasID, start, end, lineWidth, lineColor);\n  }\n}\n\n  //get the coordinates of the corner to draw the hex\n  getHexCornerCoord(center, i) {\n   let angle_deg = 60 * i   + 30;\n   let angle_rad = Math.PI / 180 * angle_deg;\n   let x = center.x + this.state.hexSize * Math.cos(angle_rad);\n  let y = center.y + this.state.hexSize * Math.sin(angle_rad);\n  return this.Point(x, y);\n }\n\n getHexParametres() {\n  let hexHeight = this.state.hexSize * 2;\n  let hexWidth = Math.sqrt(3)/2 * hexHeight;\n  let vertDist = hexHeight * 3/4;\n  let horizDist = hexWidth;\n  return { hexWidth, hexHeight, vertDist, horizDist }\n}\n\ngetCanvasPosition(canvasID) {\n  let rect = canvasID.getBoundingClientRect();\n  this.setState({\n    canvasPosition: { left:rect.left, right: rect.right, top: rect.top, bottom: rect.bottom }\n  })\n}\n   hexToPixel(h) {\n     let hexOrigin = this.state.hexOrigin;\n     let x = this.state.hexSize * Math.sqrt(3) * (h.q + h.r/2) + hexOrigin.x;\n     let y = this.state.hexSize * 3/2 * h.r + hexOrigin.y;\n     return this.Point(x, y)\n   }\n   pixelToHex(p) {\n     let size = this.state.hexSize;\n     let origin = this.state.hexOrigin;\n     let q = ((p.x - origin.x) * Math.sqrt(3)/3 - (p.y - origin.y) / 3) / size\n     let r = (p.y - origin.y) * 2/3 / size\n     return this.Hex(q, r, - q - r);\n   }\ncubeDirection(direction) {\n  const cubeDirections = [this.Hex(1, 0, -1), this.Hex(1, -1, 0), this.Hex(0, -1, 1),\n                          this.Hex(-1, 0, 1), this.Hex(-1, 1, 0), this.Hex(0, 1, -1)];\nreturn cubeDirections[direction];\n}\ncubeAdd(a, b) {\n  return this.Hex(a.q + b.q, a.r + b.r, a.s + b.s);\n}\ncubeSubstract(hexA, hexB) {\n  return this.Hex(hexA.q - hexB.q, hexA.r - hexB.r, hexA.s - hexB.s);\n}\ngetCubeNeighbor(h, direction) {\n  return this.cubeAdd(h, this.cubeDirection(direction));\n}\ngetNeighbors(h) {\n  var arr = [];\n  for (let i = 0; i <= 5; i++) {\n    const { q, r, s } = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n    arr.push(this.Hex(q, r, s));\n  }\n  return arr;\n}\n   cubeRound(cube) {\n     var rx = Math.round(cube.q)\n     var ry = Math.round(cube.r)\n     var rz = Math.round(cube.s)\n     var x_diff = Math.abs(rx - cube.q)\n     var y_diff = Math.abs(ry - cube.r)\n     var z_diff = Math.abs(rz - cube.s)\n     if (x_diff > y_diff && x_diff > z_diff) {\n       rx = -ry-rz;\n     } else if (y_diff > z_diff) {\n          ry = -rx-rz\n     } else {\n          rz = -rx-ry\n     }\n     return this.Hex(rx, ry, rz)\n   }\ngetDistanceLine(hexA, hexB) {\n  let dist = this.cubeDistance(hexA, hexB);\n  var arr = [];\n  for (let i = 0; i <= dist; i++) {\n  let center = this.hexToPixel(this.cubeRound(this.cubeLinearInt(hexA, hexB, 1.0 / dist * i)));\n  arr = [].concat(arr, center);\n  }\n  this.setState({\n    currentDistanceLine: arr\n  })\n}\ncubeDistance(hexA, hexB) {\n  const { q, r, s } = this.cubeSubstract(hexA, hexB);\n  return (Math.abs(q) + Math.abs(r) + Math.abs(s)) / 2;\n}\ncubeLinearInt(hexA, hexB, t) {\n  return this.Hex(this.linearInt(hexA.q, hexB.q, t), this.linearInt(hexA.r, hexB.r, t), this.linearInt(hexA.s, hexB.s, t));\n}\nlinearInt(a, b, t) {\n    return (a + (b - a) * t)\n}\nPoint(x, y) {\n     return {x: x, y: y}\n   }\n   Hex(q, r, s) {\n     return {q: q, r: r, s: s}\n   }\n   drawLine(canvasID, start, end, lineWidth, lineColor) {\n     const ctx = canvasID.getContext(\"2d\");\n     ctx.beginPath();\n     ctx.moveTo(start.x, start.y);\n     ctx.strokeStyle = lineColor;\n     ctx.lineWidth = lineWidth;\n     ctx.lineTo(end.x, end.y);\n     ctx.stroke();\n     ctx.closePath();\n   }\n\n   fillHex(canvasID, center, fillColor) {\n     let c0 = this.getHexCornerCoord(center, 0);\n     let c1 = this.getHexCornerCoord(center, 1);\n     let c2 = this.getHexCornerCoord(center, 2);\n     let c3 = this.getHexCornerCoord(center, 3);\n     let c4 = this.getHexCornerCoord(center, 4);\n     let c5 = this.getHexCornerCoord(center, 5);\n     const ctx = canvasID. getContext(\"2d\");\n     ctx.beginPath();\n     ctx.fillStyle = fillColor;\n     ctx.globalAlpha = 0.1;\n     ctx.moveTo(c0.x, c0.y);\n     ctx.lineTo(c1.x, c1.y);\n     ctx.lineTo(c2.x, c2.y);\n     ctx.lineTo(c3.x, c3.y);\n     ctx.lineTo(c4.x, c4.y);\n     ctx.lineTo(c5.x, c5.y);\n     ctx.closePath();\n     ctx.fill();\n   }\n   drawHexCoordinates(canvasID, center, h) {\n     const ctx = canvasID.getContext(\"2d\");\n     ctx.fillText(h.q, center.x+6, center.y);\n     ctx.fillText(h.r, center.x-3, center.y+15);\n     ctx.fillText(h.s, center.x-12, center.y);\n   }\ndrawNeighbors(h) {\n  for (let i = 0; i <= 5; i++) {\n    const { q, r, s} = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n    const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n    this.drawHex(this.canvasInteraction, this.Point(x, y), \"red\", 2);\n  }\n}\n\nhandleMouseMove(e) {\n     const { canvasWidth, canvasHeight } = this.state.canvasSize;\n     const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n     const { left, right, top, bottom } = this.state.canvasPosition;\n     var canvasPos = document.getElementById(\"canv7\");\n     let rect = canvasPos.getBoundingClientRect();\n     let offsetX = e.pageX - rect.left;\n     let offsetY = (e.pageY - (window.pageYOffset + rect.top));\n     const { q, r, s } = this.cubeRound(this.pixelToHex(this.Point(offsetX, offsetY)));\n     const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n     let playerPosition = this.state.playerPosition;\n     this.getDistanceLine(this.Hex(0,0,0), this.Hex(q,r,s));\n     /*this.getDistanceLine(this.Hex(0,0,0), this.Hex(q,r,s));*/\n     this.getPath(this.Hex(playerPosition.q, playerPosition.r, playerPosition.s), this.Hex(q,r,s));\n      if ((x >hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\nthis.setState({\n  currentHex: {q, r, s, x, y}\n})\n}\n   }\n\n   getPath(start, current) {\n  const { cameFrom } = this.state;\n  start = JSON.stringify(start);\n  current = JSON.stringify(current);\n  if(cameFrom[current] != undefined) {\n    var path = [current];\n    while (current != start) {\n      current = cameFrom[current];\n      path.push(current);\n    }\n    path = [].concat(path);\n    this.setState({\n      path: path\n    })\n  }\n}\n\ndrawPath() {\nlet path = this.state.path;\nfor (let i = 0; i <= path.length - 1; i++) {\n  const {q,r} = JSON.parse(path[i]);\n  const {x,y} = this.hexToPixel(this.Hex(q,r));\n  this.drawHex(this.canvasInteraction, this.Point(x,y), 1, \"black\", \"red\");\n}\n}\n\ndrawArrow(fromx, fromy, tox, toy){\n                var ctx = this.canvasView.getContext(\"2d\");\n                var headlen = 5;\n                var angle = Math.atan2(toy-fromy,tox-fromx);\n                ctx.beginPath();\n                ctx.moveTo(fromx, fromy);\n                ctx.lineTo(tox, toy);\n                ctx.strokeStyle = \"#cc0000\";\n                ctx.lineWidth = 3;\n                ctx.stroke();\n                ctx.beginPath();\n                ctx.moveTo(tox, toy);\n                ctx.globalAlpha = 0.3;\n                ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));\n                ctx.lineTo(tox-headlen*Math.cos(angle+Math.PI/7),toy-headlen*Math.sin(angle+Math.PI/7));\n                ctx.lineTo(tox, toy);\n                ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));\n                ctx.strokeStyle = \"#cc0000\";\n                ctx.lineWidth = 5;\n                ctx.stroke();\n                ctx.fillStyle = \"#cc0000\";\n                ctx.fill();\n            }\n\n            handleClick() {\n\nconst { currentHex, cameFrom } = this.state;\nconst { q,r,s } = currentHex;\nif(cameFrom[JSON.stringify(this.Hex(q,r,s))]) {\n  this.setState(\n    {playerPosition: this.Hex(q,r,s)},\n    this.breadthFirstSearchCallback = () => this.breadthFirstSearch(this.state.playerPosition)\n  )\n}\n   }\n\n   drawObstacles() {\n  this.state.obstacles.map((l) => {\n    const {q,r,s} = JSON.parse(l);\n    const {x,y} = this.hexToPixel(this.Hex(q,r,s));\n    this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"black\");\n  })\n}\n\nbreadthFirstSearch(playerPosition) {\nvar frontier = [playerPosition];\nvar cameFrom = {};\ncameFrom[JSON.stringify(playerPosition)] = JSON.stringify(playerPosition);\nwhile (frontier.length != 0) {\n  var current = frontier.shift();\n  let arr = this.getNeighbors(current);\n  arr.map((l) => {\n\n    if(!cameFrom.hasOwnProperty(JSON.stringify(l)) && this.state.hexPathMap.includes(JSON.stringify(l))) {\n      frontier.push(l);\n      cameFrom[JSON.stringify(l)] = JSON.stringify(current);\n    }\n  })\n\n}\ncameFrom = Object.assign({}, cameFrom);\nthis.setState({\n  cameFrom: cameFrom\n})\n}\n\n\n\n  resetSketch() {\n  window.location.reload();\n  }\n\n\nrender() {\n    return (\n      <div className=\"BFSExtra\">\n        <div className=\"title2\">\n        Breadth First Search\n        </div>\n        <div className=\"description2\">\n        <b id=\"bold\">What is it? </b>\n        <br/>\n        Breadth-First Search is an algorithm for traversing or searching tree or graph data structures.<br/>\n        It starts at the tree root and explores all of the neighboring nodes at the present depth before <br/>\n        moving on to the nodes at the next depth level.<br/>\n        \n        <br/>\n          <b id=\"bold\">How to use: </b>        <br/>\n        Click different areas of the board to see how BFS algorithm finds the shortest path!<br></br>\n          <br/>\n\n          <b id=\"bold\">How it works:</b><br/>\n        The shortest path is being calculated live by giving a distance value to every<br></br>\n        node on the board. The red arrows indicate the path that the algorithm is taking\n        from node to node.<br></br>\n        *View the second board below to see how the shortest path is determined step by step.<br/>\n        </div>\n        <canvas id=\"canv8\" ref={canvasHex => this.canvasHex = canvasHex }> </canvas>\n        <canvas id=\"canv7\" ref={canvasCoordinates => this.canvasCoordinates = canvasCoordinates }> </canvas>\n        <canvas id=\"canv6\" ref={canvasView => this.canvasView = canvasView }> </canvas>\n        <canvas id=\"canv5\" ref={canvasInteraction => this.canvasInteraction = canvasInteraction} onMouseMove = {this.handleMouseMove} onClick={this.handleClick}> </canvas>\n\n    </div>\n    )\n\n  }\n\n}","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BubbleSort/BubbleSort.js",["114","115"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/QuickSort/QuickSort.js",["116","117","118","119"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Router.js",["120"],"import React from 'react';\nimport { Route, Redirect } from 'react-router-dom';\nimport PathfindingVisualizer from '../PathfindingVisualizer/PathfindingVisualizer';\nimport QuickSort from '../QuickSort/QuickSort';\nimport BubbleSort from '../BubbleSort/BubbleSort';\nimport BFS from '../BFS/BFS';\nimport BFS2 from '../BFS/BFS2';\nimport AStar from '../A*Star/A_star';\nimport TravelingSalesperson from '../Traveling_Salesperson/TravelingSalesperson';\nimport HomePage from '../HomePage/HomePage';\n\nexport default function Router(){\n    return(\n        <div>\n            <Route path='/landing'>\n                <HomePage />\n            </Route>\n            \n            <Route path='/dijkstras'>\n                <PathfindingVisualizer />\n            </Route>\n\n            <Route path='/bfs'>\n                <BFS2 />\n                <BFS />\n            </Route>\n\n            <Route path='/qsort'>\n                <QuickSort />\n            </Route>\n\n            <Route path='/bsort'>\n                <BubbleSort />\n            </Route>\n\n            <Route path='/astar'>\n                <AStar />\n            </Route>\n\n            <Route path='/travelingsalesperson'>\n                <TravelingSalesperson />\n            </Route>\n\n            {/* <Redirect from='/' to='/landing' /> */}\n        </div>\n    )\n}","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Navbar.js",["121"],"import React from 'react';\nimport { Link } from 'react-router-dom';\nimport img from '../../algoseeker.png'\nimport './Navbar.css'\n\nconst Navbar = () => {\n    return(\n        <nav>\n                <div>\n                    <Link to='/landing' style={{padding: 20}}>\n                        <img src={img} style={{height:'50px', width:'50px'}} className='logobar' />\n                    </Link>\n                </div>\n                <div className='nav1'>\n                    <Link to='/landing' style={{ padding: 20, textDecoration:'None', color:'white', fontWeight:'bold', fontSize: 'large'}}> \n                    Choose your Algorithm!: </Link>\n\n                    <Link to='/dijkstras' style={{padding: 20, color:'white', fontWeight:'bold', fontSize: 'large'}}>\n                    Dijkstra\n                    </Link>\n\n                    <Link to='/bfs' style={{padding: 20, color:'white', fontWeight:'bold', fontSize: 'large'}}>\n                    Breadth-First Search\n                    </Link>\n\n                    <Link to='/bsort' style={{padding: 20, color:'white', fontWeight:'bold', fontSize: 'large'}}>\n                    Bubble Sort\n                    </Link>\n\n                    <Link to='/qsort' style={{padding: 20, color:'white', fontWeight:'bold', fontSize: 'large'}}>\n                    Quick Sort\n                    </Link>\n\n                    <Link to='/astar' style={{padding: 20, color:'white', fontWeight:'bold', fontSize: 'large'}}>\n                    A* Search\n                    </Link>\n\n                    <Link to='/travelingsalesperson' style={{padding: 20, color:'white', fontWeight:'bold', fontSize: 'large'}}>\n                    Traveling Salesperson w/ Genetic Algo\n                    </Link>\n                </div>\n        </nav>\n    )\n}\n\nexport default Navbar;","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/A*Star/A_star.js",["122"],"import React, { Component } from 'react';\nimport P5Wrapper from 'react-p5-wrapper';\n\nexport default class AStar extends Component {\n    sketch(p){\n\n        // Function to delete element from the array\n        function removeFromArray(arr, elt) {\n            // Could use indexOf here instead to be more efficient\n            for (let i = arr.length - 1; i >= 0; i--) {\n              if (arr[i] == elt) {\n                arr.splice(i, 1);\n              }\n            }\n          }\n          \n          // An educated guess of how far it is between two points\n          function heuristic(a, b) {\n            let d = p.dist(a.i, a.j, b.i, b.j);\n            // let d = abs(a.i - b.i) + abs(a.j - b.j);\n            return d;\n          }\n          \n          // How many columns and rows?\n          let cols = 50;\n          let rows = 50;\n          \n          // This will be the 2D array\n          let grid = new Array(cols);\n          \n          // Open and closed set\n          let openSet = [];\n          let closedSet = [];\n          \n          // Start and end\n          let start;\n          let end;\n          \n          // Width and height of each cell of grid\n          let w, h;\n          \n          // The road taken\n          let path = [];\n          \n            p.setup = () => {\n            p.createCanvas(800, 800);\n            console.log('A*');\n          \n            // Grid cell size\n            w = p.width / cols;\n            h = p.height / rows;\n          \n            // Making a 2D array\n            for (let i = 0; i < cols; i++) {\n              grid[i] = new Array(rows);\n            }\n          \n            for (let i = 0; i < cols; i++) {\n              for (let j = 0; j < rows; j++) {\n                grid[i][j] = new Spot(i, j);\n              }\n            }\n          \n            // All the neighbors\n            for (let i = 0; i < cols; i++) {\n              for (let j = 0; j < rows; j++) {\n                grid[i][j].addNeighbors(grid);\n              }\n            }\n          \n            // Start and end\n            start = grid[0][0];\n            end = grid[cols - 1][rows - 1];\n            start.wall = false;\n            end.wall = false;\n          \n            // openSet starts with beginning only\n            openSet.push(start);\n\n            let button = p.createButton(\"visualize\");\n            button.mousePressed(resetSketch);\n            button.parent(\"resetAStar\");\n          }\n          function resetSketch() {\n            window.location.reload();\n        }\n          \n          p.draw = () => {\n            // Am I still searching?\n            if (openSet.length > 0) {\n              // Best next option\n              let winner = 0;\n              for (let i = 0; i < openSet.length; i++) {\n                if (openSet[i].f < openSet[winner].f) {\n                  winner = i;\n                }\n              }\n              let current = openSet[winner];\n          \n              // Did I finish?\n              if (current === end) {\n                p.noLoop();\n                console.log('DONE!');\n              }\n          \n              // Best option moves from openSet to closedSet\n              removeFromArray(openSet, current);\n              closedSet.push(current);\n          \n              // Check all the neighbors\n              let neighbors = current.neighbors;\n              for (let i = 0; i < neighbors.length; i++) {\n                let neighbor = neighbors[i];\n          \n                // Valid next spot?\n                if (!closedSet.includes(neighbor) && !neighbor.wall) {\n                  let tempG = current.g + heuristic(neighbor, current);\n          \n                  // Is this a better path than before?\n                  let newPath = false;\n                  if (openSet.includes(neighbor)) {\n                    if (tempG < neighbor.g) {\n                      neighbor.g = tempG;\n                      newPath = true;\n                    }\n                  } else {\n                    neighbor.g = tempG;\n                    newPath = true;\n                    openSet.push(neighbor);\n                  }\n          \n                  // Yes, it's a better path\n                  if (newPath) {\n                    neighbor.h = heuristic(neighbor, end);\n                    neighbor.f = neighbor.g + neighbor.h;\n                    neighbor.previous = current;\n                  }\n                }\n              }\n              // Uh oh, no solution\n            } else {\n              console.log('no solution');\n              p.noLoop();\n              return;\n            }\n          \n            // Draw current state of everything\n            p.background(255);\n          \n            for (let i = 0; i < cols; i++) {\n              for (let j = 0; j < rows; j++) {\n                grid[i][j].show();\n              }\n            }\n          \n            for (let i = 0; i < closedSet.length; i++) {\n              closedSet[i].show(p.color(255, 0, 0, 50));\n            }\n          \n            for (let i = 0; i < openSet.length; i++) {\n              openSet[i].show(p.color(0, 255, 0, 50));\n            }\n          \n            // Find the path by working backwards\n            path = [];\n            let temp = path;\n            path.push(temp);\n            while (temp.previous) {\n              path.push(temp.previous);\n              temp = temp.previous;\n            }\n          \n            // for (let i = 0; i < path.length; i++) {\n            // path[i].show(color(0, 0, 255));\n            //}\n          \n            // Drawing path as continuous line\n            p.noFill();\n            p.stroke(255, 0, 200);\n            p.strokeWeight(w / 2);\n            p.beginShape();\n            for (let i = 0; i < path.length; i++) {\n              p.vertex(path[i].i * w + w / 2, path[i].j * h + h / 2);\n            }\n            p.endShape();\n          }\n          // An object to describe a spot in the grid\n         function Spot(i, j) {\n              // Location\n              this.i = i;\n              this.j = j;\n            \n              // f, g, and h values for A*\n              this.f = 0;\n              this.g = 0;\n              this.h = 0;\n            \n              // Neighbors\n              this.neighbors = [];\n            \n              // Where did I come from?\n              this.previous = undefined;\n            \n              // Am I a wall?\n              this.wall = false;\n              if (p.random(1) < 0.4) {\n                this.wall = true;\n              }\n            \n              // Display me\n              this.show = function(col) {\n                if (this.wall) {\n                  p.fill(0);\n                  p.noStroke();\n                  p.ellipse(this.i * w + w / 2, this.j * h + h / 2, w / 2, h / 2);\n                } else if (col) {\n                  p.fill(col);\n                  p.rect(this.i * w, this.j * h, w, h);\n                }\n              };\n            \n              // Figure out who my neighbors are\n              this.addNeighbors = function(grid) {\n                var i = this.i;\n                var j = this.j;\n                if (i < cols - 1) {\n                  this.neighbors.push(grid[i + 1][j]);\n                }\n                if (i > 0) {\n                  this.neighbors.push(grid[i - 1][j]);\n                }\n                if (j < rows - 1) {\n                  this.neighbors.push(grid[i][j + 1]);\n                }\n                if (j > 0) {\n                  this.neighbors.push(grid[i][j - 1]);\n                }\n                if (i > 0 && j > 0) {\n                  this.neighbors.push(grid[i - 1][j - 1]);\n                }\n                if (i < cols - 1 && j > 0) {\n                  this.neighbors.push(grid[i + 1][j - 1]);\n                }\n                if (i > 0 && j < rows - 1) {\n                  this.neighbors.push(grid[i - 1][j + 1]);\n                }\n                if (i < cols - 1 && j < rows - 1) {\n                  this.neighbors.push(grid[i + 1][j + 1]);\n                }\n              };\n        }\n    }\n    render(){\n        return(\n            <section id='AStar'>\n                <div className='title5'>\n                    A* Search Algorithm\n                </div>\n\n                <div className=\"dijkstraDescription\">\n                <b id='bold'>What is it?:</b> <br/>\n                    The A* search is a graph traversal and path searching algorithm which is often<br />\n                    used in many fields of computer science due to it's completeness, optimality and efficiency.<br/>\n                    <br/>\n                <b id=\"bold\"> How it works: </b> \n                    <br />\n                    Like Dijkstra, A* works by making a shortest path tree from the <b>start</b> node to the <br/>\n                    <b>target</b> node.<br/>\n                    <br/>\n                <b id='bold'>Use in the real world:</b><br/>\n                    - It's used in various applications such as maps. In maps, the algorithm is used to calculate the <br/> \n                    shortest distance between the initial node to the destination node.<br/>\n                    <br/>\n                <b id=\"bold\">Note: </b>\n                    Although A* search algorithm's efficiency - one major practical drawback is it's<br/>\n                    O(bd) space complexity meaning that it stores all generated nodes memory.  <br></br>\n                </div>\n\n                <div id=\"resetAStar\"></div>\n                <P5Wrapper sketch={this.sketch}></P5Wrapper>\n            </section>\n\n        )\n    }\n}\n","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Traveling_Salesperson/TravelingSalesperson.js",["123"],"import React, { Component } from 'react';\nimport P5Wrapper from 'react-p5-wrapper';\n\nexport default class TravelingSalesperson extends Component {\n    sketch(p){\n\n        let cities = [];\n        let totalCities = 12;\n\n        let popSize = 500;\n        let population = [];\n        let fitness = [];\n\n        let recordDistance = Infinity;\n        let bestEver;\n        let currentBest;\n\n        let statusP;\n\n        p.setup = () => {\n        p.createCanvas(800, 800);\n        let order = [];\n        for (let i = 0; i < totalCities; i++) {\n            let v = p.createVector(p.random(p.width), p.random(p.height / 2));\n            cities[i] = v;\n            order[i] = i;\n        }\n\n        for (let i = 0; i < popSize; i++) {\n            population[i] = p.shuffle(order);\n        }\n        statusP = p.createP('').style('font-size', '32pt');\n\n        let button = p.createButton(\"reset\");\n            button.mousePressed(resetSketch);\n            button.parent(\"resetTravelingSalesperson\");\n        }\n\n        function resetSketch() {\n            window.location.reload();\n        }\n\n        p.draw = () => {\n        p.background(0);\n\n        // GA\n        calculateFitness();\n        normalizeFitness();\n        nextGeneration();\n\n        p.stroke(255);\n        p.strokeWeight(4);\n        p.noFill();\n        p.beginShape();\n        for (let i = 0; i < bestEver.length; i++) {\n            let n = bestEver[i];\n            p.vertex(cities[n].x, cities[n].y);\n            p.ellipse(cities[n].x, cities[n].y, 16, 16);\n        }\n        p.endShape();\n\n        p.translate(0, p.height / 2);\n        p.stroke(255);\n        p.strokeWeight(4);\n        p.noFill();\n        p.beginShape();\n        for (let i = 0; i < currentBest.length; i++) {\n            let n = currentBest[i];\n            p.vertex(cities[n].x, cities[n].y);\n            p.ellipse(cities[n].x, cities[n].y, 16, 16);\n        }\n        p.endShape();\n        }\n\n        function swap(a, i, j) {\n        let temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n        }\n\n        function calcDistance(points, order) {\n        let sum = 0;\n        for (let i = 0; i < order.length - 1; i++) {\n            let cityAIndex = order[i];\n            let cityA = points[cityAIndex];\n            let cityBIndex = order[i + 1];\n            let cityB = points[cityBIndex];\n            let d = p.dist(cityA.x, cityA.y, cityB.x, cityB.y);\n            sum += d;\n        }\n        return sum;\n        }\n        function calculateFitness() {\n            let currentRecord = Infinity;\n            for (let i = 0; i < population.length; i++) {\n              let d = calcDistance(cities, population[i]);\n              if (d < recordDistance) {\n                recordDistance = d;\n                bestEver = population[i];\n              }\n              if (d < currentRecord) {\n                currentRecord = d;\n                currentBest = population[i];\n              }\n              fitness[i] = 1 / (p.pow(d, 8) + 1);\n            }\n          }\n          \n          function normalizeFitness() {\n            let sum = 0;\n            for (let i = 0; i < fitness.length; i++) {\n              sum += fitness[i];\n            }\n            for (let i = 0; i < fitness.length; i++) {\n              fitness[i] = fitness[i] / sum;\n            }\n          }\n          \n          function nextGeneration() {\n            let newPopulation = [];\n            for (let i = 0; i < population.length; i++) {\n              let orderA = pickOne(population, fitness);\n              let orderB = pickOne(population, fitness);\n              let order = crossOver(orderA, orderB);\n              mutate(order, 0.01);\n              newPopulation[i] = order;\n            }\n            population = newPopulation;\n          }\n          \n          function pickOne(list, prob) {\n            let index = 0;\n            let r = p.random(1);\n          \n            while (r > 0) {\n              r = r - prob[index];\n              index++;\n            }\n            index--;\n            return list[index].slice();\n          }\n          \n          function crossOver(orderA, orderB) {\n            let start = p.floor(p.random(orderA.length));\n            let end = p.floor(p.random(start + 1, orderA.length));\n            let neworder = orderA.slice(start, end);\n            for (let i = 0; i < orderB.length; i++) {\n              let city = orderB[i];\n              if (!neworder.includes(city)) {\n                neworder.push(city);\n              }\n            }\n            return neworder;\n          }\n          \n          function mutate(order, mutationRate) {\n            for (let i = 0; i < totalCities; i++) {\n              if (p.random(1) < mutationRate) {\n                let indexA = p.floor(p.random(order.length));\n                let indexB = (indexA + 1) % totalCities;\n                swap(order, indexA, indexB);\n              }\n            }\n        }\n    }\n    render() {\n        return(\n            <section id='geneticAlgo'>\n                <div className='title5'>\n                    Traveling Salesperson \n                    <br></br>with Genetic Algorithm\n                </div>\n\n                <div className=\"dijkstraDescription\">\n                <b id='bold'>What is it?:</b> <br/>\n                    <b>Traveling Salesperson:</b><br/>\n                    - This is a common computer science problem which says that a salesperson is given<br/>\n                    a set of cities, he has to find the shortest path to visit each city exactly once and <br/>\n                    return to the starting city.<br/>\n                    <b>Genetic Algorithm:</b><br/>\n                    - This algorithm is inspired by the process that supports the evolution of life. (Darwin's Theory of Evolution)<br/>\n                    It's designed to replicate the natural selection process - survival of the fittest.<br/>\n                    <br/>\n                <b id=\"bold\"> How it works: </b> \n                    <br />\n                    <b>1.</b>\n                        Initialize the population randomly.\n                    <br/>\n                    <b>2.</b>\n                        Determine the fitness of the chromosome.\n                    <br/>    \n                    <b>3.</b>\n                        <b>Until done repeat:</b><br/>\n                        1) Select parents -> \n                        2) Perform crossover and mutation ->\n                        3) Calculate the fitness of the new population ->\n                        4) Append it to the gene pool<br/>\n\n                    <br/>\n                <b id='bold'>Use in the real world:</b><br/>\n                    - They are commonly used to generate high quality solutions for optimization and search problems<br/> \n                    - Genetic Algo concepts can be applied to engineering problems such as optimization for gas pipeline systems.<br/> \n                    As well as, structure optimization.<br/>\n                    <br/>\n                </div>\n\n                <div id=\"resetTravelingSalesperson\"></div>\n                <P5Wrapper sketch={this.sketch}></P5Wrapper>\n            </section>\n        )\n    }\n}\n ","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/HomePage/HomePage.js",["124"],{"ruleId":"125","replacedBy":"126"},{"ruleId":"127","replacedBy":"128"},{"ruleId":"129","severity":1,"message":"130","line":5,"column":3,"nodeType":"131","messageId":"132","endLine":5,"endColumn":12},{"ruleId":"129","severity":1,"message":"133","line":6,"column":3,"nodeType":"131","messageId":"132","endLine":6,"endColumn":10},{"ruleId":"129","severity":1,"message":"134","line":7,"column":3,"nodeType":"131","messageId":"132","endLine":7,"endColumn":11},{"ruleId":"129","severity":1,"message":"135","line":8,"column":3,"nodeType":"131","messageId":"132","endLine":8,"endColumn":7},{"ruleId":"129","severity":1,"message":"136","line":9,"column":3,"nodeType":"131","messageId":"132","endLine":9,"endColumn":9},{"ruleId":"129","severity":1,"message":"137","line":10,"column":3,"nodeType":"131","messageId":"132","endLine":10,"endColumn":8},{"ruleId":"129","severity":1,"message":"138","line":11,"column":3,"nodeType":"131","messageId":"132","endLine":11,"endColumn":7},{"ruleId":"129","severity":1,"message":"139","line":12,"column":3,"nodeType":"131","messageId":"132","endLine":12,"endColumn":7},{"ruleId":"129","severity":1,"message":"140","line":14,"column":3,"nodeType":"131","messageId":"132","endLine":14,"endColumn":10},{"ruleId":"129","severity":1,"message":"141","line":142,"column":15,"nodeType":"131","messageId":"132","endLine":142,"endColumn":16},{"ruleId":"129","severity":1,"message":"142","line":142,"column":18,"nodeType":"131","messageId":"132","endLine":142,"endColumn":19},{"ruleId":"129","severity":1,"message":"143","line":142,"column":21,"nodeType":"131","messageId":"132","endLine":142,"endColumn":22},{"ruleId":"144","severity":1,"message":"145","line":157,"column":34,"nodeType":"146","messageId":"147","endLine":157,"endColumn":36},{"ruleId":"129","severity":1,"message":"143","line":171,"column":23,"nodeType":"131","messageId":"132","endLine":171,"endColumn":24},{"ruleId":"129","severity":1,"message":"148","line":423,"column":34,"nodeType":"131","messageId":"132","endLine":423,"endColumn":42},{"ruleId":"129","severity":1,"message":"149","line":423,"column":44,"nodeType":"131","messageId":"132","endLine":423,"endColumn":53},{"ruleId":"129","severity":1,"message":"150","line":439,"column":8,"nodeType":"131","messageId":"132","endLine":439,"endColumn":22},{"ruleId":"144","severity":1,"message":"145","line":462,"column":27,"nodeType":"146","messageId":"147","endLine":462,"endColumn":29},{"ruleId":"151","severity":1,"message":"152","line":477,"column":17,"nodeType":"153","messageId":"154","endLine":477,"endColumn":19},{"ruleId":"155","severity":1,"message":"156","line":485,"column":15,"nodeType":"146","messageId":"157","endLine":490,"endColumn":8},{"ruleId":"144","severity":1,"message":"145","line":485,"column":19,"nodeType":"146","messageId":"147","endLine":485,"endColumn":21},{"ruleId":"129","severity":1,"message":"158","line":1,"column":16,"nodeType":"131","messageId":"132","endLine":1,"endColumn":25},{"ruleId":"129","severity":1,"message":"141","line":116,"column":11,"nodeType":"131","messageId":"132","endLine":116,"endColumn":12},{"ruleId":"129","severity":1,"message":"142","line":116,"column":14,"nodeType":"131","messageId":"132","endLine":116,"endColumn":15},{"ruleId":"129","severity":1,"message":"143","line":116,"column":17,"nodeType":"131","messageId":"132","endLine":116,"endColumn":18},{"ruleId":"129","severity":1,"message":"159","line":116,"column":20,"nodeType":"131","messageId":"132","endLine":116,"endColumn":21},{"ruleId":"129","severity":1,"message":"160","line":116,"column":23,"nodeType":"131","messageId":"132","endLine":116,"endColumn":24},{"ruleId":"129","severity":1,"message":"143","line":129,"column":19,"nodeType":"131","messageId":"132","endLine":129,"endColumn":20},{"ruleId":"151","severity":1,"message":"152","line":153,"column":12,"nodeType":"153","messageId":"154","endLine":153,"endColumn":14},{"ruleId":"161","severity":1,"message":"162","line":321,"column":18,"nodeType":"163","messageId":"164","endLine":321,"endColumn":38,"fix":"165"},{"ruleId":"129","severity":1,"message":"148","line":350,"column":35,"nodeType":"131","messageId":"132","endLine":350,"endColumn":43},{"ruleId":"129","severity":1,"message":"149","line":350,"column":45,"nodeType":"131","messageId":"132","endLine":350,"endColumn":54},{"ruleId":"129","severity":1,"message":"166","line":351,"column":14,"nodeType":"131","messageId":"132","endLine":351,"endColumn":18},{"ruleId":"129","severity":1,"message":"167","line":351,"column":20,"nodeType":"131","messageId":"132","endLine":351,"endColumn":25},{"ruleId":"129","severity":1,"message":"168","line":351,"column":27,"nodeType":"131","messageId":"132","endLine":351,"endColumn":30},{"ruleId":"129","severity":1,"message":"169","line":351,"column":32,"nodeType":"131","messageId":"132","endLine":351,"endColumn":38},{"ruleId":"151","severity":1,"message":"170","line":373,"column":24,"nodeType":"153","messageId":"154","endLine":373,"endColumn":26},{"ruleId":"151","severity":1,"message":"170","line":375,"column":20,"nodeType":"153","messageId":"154","endLine":375,"endColumn":22},{"ruleId":"144","severity":1,"message":"145","line":432,"column":32,"nodeType":"146","messageId":"147","endLine":432,"endColumn":34},{"ruleId":"151","severity":1,"message":"170","line":443,"column":24,"nodeType":"153","messageId":"154","endLine":443,"endColumn":26},{"ruleId":"155","severity":1,"message":"156","line":446,"column":11,"nodeType":"146","messageId":"157","endLine":452,"endColumn":4},{"ruleId":"144","severity":1,"message":"145","line":446,"column":15,"nodeType":"146","messageId":"147","endLine":446,"endColumn":17},{"ruleId":"129","severity":1,"message":"171","line":8,"column":13,"nodeType":"131","messageId":"132","endLine":8,"endColumn":14},{"ruleId":"129","severity":1,"message":"172","line":9,"column":13,"nodeType":"131","messageId":"132","endLine":9,"endColumn":14},{"ruleId":"151","severity":1,"message":"170","line":92,"column":13,"nodeType":"153","messageId":"154","endLine":92,"endColumn":15},{"ruleId":"151","severity":1,"message":"152","line":105,"column":21,"nodeType":"153","messageId":"154","endLine":105,"endColumn":23},{"ruleId":"151","severity":1,"message":"152","line":107,"column":28,"nodeType":"153","messageId":"154","endLine":107,"endColumn":30},{"ruleId":"151","severity":1,"message":"152","line":109,"column":28,"nodeType":"153","messageId":"154","endLine":109,"endColumn":30},{"ruleId":"129","severity":1,"message":"173","line":2,"column":17,"nodeType":"131","messageId":"132","endLine":2,"endColumn":25},{"ruleId":"174","severity":1,"message":"175","line":11,"column":25,"nodeType":"176","endLine":11,"endColumn":100},{"ruleId":"151","severity":1,"message":"152","line":11,"column":26,"nodeType":"153","messageId":"154","endLine":11,"endColumn":28},{"ruleId":"129","severity":1,"message":"177","line":32,"column":9,"nodeType":"131","messageId":"132","endLine":32,"endColumn":16},{"ruleId":"174","severity":1,"message":"175","line":92,"column":11,"nodeType":"176","endLine":92,"endColumn":28},"no-native-reassign",["178"],"no-negated-in-lhs",["179"],"no-unused-vars","'Container' is defined but never used.","Identifier","unusedVar","'Divider' is defined but never used.","'Dropdown' is defined but never used.","'Grid' is defined but never used.","'Header' is defined but never used.","'Image' is defined but never used.","'List' is defined but never used.","'Menu' is defined but never used.","'Segment' is defined but never used.","'q' is assigned a value but never used.","'r' is assigned a value but never used.","'s' is assigned a value but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","'vertDist' is assigned a value but never used.","'horizDist' is assigned a value but never used.","'playerPosition' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'cameFrom', 'cameFrom', 'current'.","unsafeRefs","'Component' is defined but never used.","'x' is assigned a value but never used.","'y' is assigned a value but never used.","no-whitespace-before-property","Unexpected whitespace before property getContext.","MemberExpression","unexpectedWhitespace",{"range":"180","text":"181"},"'left' is assigned a value but never used.","'right' is assigned a value but never used.","'top' is assigned a value but never used.","'bottom' is assigned a value but never used.","Expected '!==' and instead saw '!='.","'j' is assigned a value but never used.","'w' is assigned a value but never used.","'Redirect' is defined but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'statusP' is assigned a value but never used.","no-global-assign","no-unsafe-negation",[12189,12191],"."]