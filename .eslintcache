[{"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/index.js":"1","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/App.js":"2","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/reportWebVitals.js":"3","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/PathfindingVisualizer.js":"4","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/Node/Node.js":"5","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/dijkstra/djikstra.js":"6","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS.jsx":"7","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS2.js":"8","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BubbleSort/BubbleSort.js":"9","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/QuickSort/QuickSort.js":"10","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Router.js":"11","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Navbar.js":"12","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/A*Star/A_star.js":"13","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Traveling_Salesperson/TravelingSalesperson.js":"14","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/HomePage/HomePage.js":"15"},{"size":500,"mtime":1607018973582,"results":"16","hashOfConfig":"17"},{"size":396,"mtime":1607891567660,"results":"18","hashOfConfig":"17"},{"size":362,"mtime":1607018973582,"results":"19","hashOfConfig":"17"},{"size":6367,"mtime":1609050690891,"results":"20","hashOfConfig":"17"},{"size":689,"mtime":1607735611637,"results":"21","hashOfConfig":"17"},{"size":2464,"mtime":1607735320937,"results":"22","hashOfConfig":"17"},{"size":18366,"mtime":1608770245343,"results":"23","hashOfConfig":"17"},{"size":18483,"mtime":1608770093864,"results":"24","hashOfConfig":"17"},{"size":3157,"mtime":1609050333210,"results":"25","hashOfConfig":"17"},{"size":4611,"mtime":1609050364064,"results":"26","hashOfConfig":"17"},{"size":1302,"mtime":1609117802431,"results":"27","hashOfConfig":"17"},{"size":1818,"mtime":1609117783714,"results":"28","hashOfConfig":"17"},{"size":9552,"mtime":1609050386497,"results":"29","hashOfConfig":"17"},{"size":7143,"mtime":1609050343023,"results":"30","hashOfConfig":"17"},{"size":3205,"mtime":1609132431399,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},"zofrmq",{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"34"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":1,"source":"50","usedDeprecatedRules":"34"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"53","messages":"54","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"55","messages":"56","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"57","messages":"58","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"59","messages":"60","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"61","messages":"62","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"63","messages":"64","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/index.js",[],["65","66"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/App.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/reportWebVitals.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/PathfindingVisualizer.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/Node/Node.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/dijkstra/djikstra.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS.jsx",["67","68","69","70","71","72","73","74","75","76","77","78"],"import React, {Component} from 'react';\n\nvar DUMMY_OBSTACLES = \n    ['{\"q\":6,\"r\":9,\"s\":-15}', '{\"q\":7,\"r\":8,\"s\":-15}', \n    '{\"q\":7,\"r\":7,\"s\":-14}', '{\"q\":8,\"r\":6,\"s\":-14}', \n    '{\"q\":8,\"r\":5,\"s\":-13}', '{\"q\":9,\"r\":4,\"s\":-13}', \n    '{\"q\":5,\"r\":9,\"s\":-14}', '{\"q\":4,\"r\":9,\"s\":-13}', \n    '{\"q\":3,\"r\":9,\"s\":-12}', \n    '{\"q\":2,\"r\":9,\"s\":-11}', '{\"q\":1,\"r\":9,\"s\":-10}', \n    '{\"q\":0,\"r\":9,\"s\":-9}', '{\"q\":-1,\"r\":9,\"s\":-8}', \n    '{\"q\":-2,\"r\":9,\"s\":-7}', '{\"q\":-3,\"r\":9,\"s\":-6}',\n    '{\"q\":-4,\"r\":9,\"s\":-5}', '{\"q\":-5,\"r\":9,\"s\":-4}', \n    '{\"q\":-6,\"r\":9,\"s\":-3}', '{\"q\":-7,\"r\":9,\"s\":-2}', \n    '{\"q\":-8,\"r\":9,\"s\":-1}', '{\"q\":-9,\"r\":9,\"s\":0}', \n    '{\"q\":-11,\"r\":9,\"s\":2}', '{\"q\":-10,\"r\":9,\"s\":1}',\n    '{\"q\":-12,\"r\":9,\"s\":3}', '{\"q\":-13,\"r\":9,\"s\":4}', \n    '{\"q\":-14,\"r\":9,\"s\":5}', '{\"q\":-15,\"r\":9,\"s\":6}', \n    '{\"q\":-15,\"r\":8,\"s\":7}', '{\"q\":-14,\"r\":7,\"s\":7}', \n    '{\"q\":-14,\"r\":6,\"s\":8}', '{\"q\":-13,\"r\":5,\"s\":8}',\n    '{\"q\":-13,\"r\":4,\"s\":9}', '{\"q\":-12,\"r\":3,\"s\":9}', \n    '{\"q\":-12,\"r\":2,\"s\":10}', '{\"q\":-11,\"r\":1,\"s\":10}', \n    '{\"q\":-11,\"r\":0,\"s\":11}', '{\"q\":-10,\"r\":-1,\"s\":11}', \n    '{\"q\":-10,\"r\":-2,\"s\":12}',\n    '{\"q\":-9,\"r\":-3,\"s\":12}', '{\"q\":-9,\"r\":-4,\"s\":13}', \n    '{\"q\":-8,\"r\":-5,\"s\":13}', '{\"q\":-8,\"r\":-6,\"s\":14}', \n    '{\"q\":-7,\"r\":-7,\"s\":14}', '{\"q\":-7,\"r\":-8,\"s\":15}', \n    '{\"q\":-6,\"r\":-9,\"s\":15}',\n    '{\"q\":-5,\"r\":-9,\"s\":14}', '{\"q\":-4,\"r\":-9,\"s\":13}', \n    '{\"q\":-3,\"r\":-9,\"s\":12}', '{\"q\":-2,\"r\":-9,\"s\":11}', \n    '{\"q\":-1,\"r\":-9,\"s\":10}', '{\"q\":0,\"r\":-9,\"s\":9}', \n    '{\"q\":1,\"r\":-9,\"s\":8}', '{\"q\":2,\"r\":-9,\"s\":7}',\n    '{\"q\":3,\"r\":-9,\"s\":6}', '{\"q\":4,\"r\":-9,\"s\":5}', \n    '{\"q\":5,\"r\":-9,\"s\":4}', '{\"q\":6,\"r\":-9,\"s\":3}', \n    '{\"q\":7,\"r\":-9,\"s\":2}', '{\"q\":8,\"r\":-9,\"s\":1}', \n    '{\"q\":9,\"r\":-9,\"s\":0}', '{\"q\":10,\"r\":-9,\"s\":-1}',\n    '{\"q\":11,\"r\":-9,\"s\":-2}', '{\"q\":12,\"r\":-9,\"s\":-3}', \n    '{\"q\":13,\"r\":-9,\"s\":-4}', '{\"q\":14,\"r\":-9,\"s\":-5}', \n    '{\"q\":15,\"r\":-9,\"s\":-6}', '{\"q\":15,\"r\":-8,\"s\":-7}', \n    '{\"q\":14,\"r\":-7,\"s\":-7}',\n    '{\"q\":14,\"r\":-6,\"s\":-8}', '{\"q\":13,\"r\":-5,\"s\":-8}', \n    '{\"q\":13,\"r\":-4,\"s\":-9}', '{\"q\":12,\"r\":-3,\"s\":-9}', \n    '{\"q\":12,\"r\":-2,\"s\":-10}', '{\"q\":11,\"r\":-1,\"s\":-10}', \n    '{\"q\":11,\"r\":0,\"s\":-11}',\n    '{\"q\":10,\"r\":1,\"s\":-11}', '{\"q\":10,\"r\":2,\"s\":-12}', \n    '{\"q\":9,\"r\":3,\"s\":-12}', '{\"q\":-2, \"r\":-8, \"s\":10}', \n    '{\"q\": -3, \"r\": -7, \"s\": 10}', '{\"q\": -4, \"r\": -6, \"s\": 10}', \n    '{\"q\": -5, \"r\": -5, \"s\": 10}',\n    '{\"q\": -6, \"r\": -4, \"s\": 10}', '{\"q\": -7, \"r\": -4, \"s\": 11}', \n    '{\"q\": 4, \"r\": -7, \"s\": 3}', '{\"q\": 3, \"r\": -6, \"s\": 3}', \n    '{\"q\": 2, \"r\": -5, \"s\": 3}',\n    '{\"q\": 1, \"r\": -4, \"s\": 3}',\n    '{\"q\": 2, \"r\": -4, \"s\": 2}',\n    '{\"q\": 3, \"r\": -4, \"s\": 1}',\n    '{\"q\": 4, \"r\": -4, \"s\": 0}',\n    '{\"q\": 9, \"r\": -3, \"s\": -6}',\n    '{\"q\": 10, \"r\": -3, \"s\": -7}',\n    '{\"q\": 8, \"r\": -2, \"s\": -6}',\n    '{\"q\": 7, \"r\": -2, \"s\": -5}',\n    '{\"q\": 4, \"r\": -2, \"s\": -2}',\n    '{\"q\": 4, \"r\": -1, \"s\": -3}',\n    '{\"q\": 4, \"r\": 0, \"s\": -4}',\n    '{\"q\": 4, \"r\": 1, \"s\": -5}',\n    '{\"q\": 3, \"r\": 2, \"s\": -5}',\n    '{\"q\": 2, \"r\": 3, \"s\": -5}',\n    '{\"q\": 1, \"r\": 4, \"s\": -5}',\n    '{\"q\": -0, \"r\": 5, \"s\": -5}',\n    '{\"q\": -1, \"r\": 6, \"s\": -5}',\n    '{\"q\": -2, \"r\": 7, \"s\": -5}',\n    '{\"q\": 4, \"r\": 5, \"s\": -9}',\n    '{\"q\": 4, \"r\": 6, \"s\": -10}',\n    '{\"q\": 5, \"r\": 6, \"s\": -11}',\n    '{\"q\": 5, \"r\": 7, \"s\": -12}',\n    '{\"q\": -5, \"r\": 7, \"s\": -2}',\n    '{\"q\": -5, \"r\": 8, \"s\": -3}',\n    '{\"q\": -5, \"r\": 6, \"s\": -1}',\n    '{\"q\": -5, \"r\": 5, \"s\": 0}',\n    '{\"q\": -4, \"r\": 4, \"s\": -0}',\n    '{\"q\": -3, \"r\": 3, \"s\": -0}',\n    '{\"q\": -5, \"r\": 3, \"s\": 2}',\n    '{\"q\": -6, \"r\": 4, \"s\": 2}',\n    '{\"q\": -4, \"r\": 2, \"s\": 2}',\n    '{\"q\": -4, \"r\": 1, \"s\": 3}',\n    '{\"q\": -7, \"r\": 4, \"s\": 3}',\n    '{\"q\": -8, \"r\": 4, \"s\": 4}',\n    '{\"q\": -9, \"r\": 4, \"s\": 5}',\n    '{\"q\": -10, \"r\": 4, \"s\": 6}',\n    '{\"q\": -11, \"r\": 4, \"s\": 7}',\n    '{\"q\": -12, \"r\": 4, \"s\": 8}',\n    '{\"q\": -6, \"r\": 1, \"s\": 5}',\n    '{\"q\": -6, \"r\": 0, \"s\": 6}',\n    '{\"q\": -6, \"r\": -1, \"s\": 7}',\n    '{\"q\": -6, \"r\": -2, \"s\": 8}',\n    '{\"q\": -2, \"r\": -1, \"s\": 3}',\n    '{\"q\": -2, \"r\": -2, \"s\": 4}']\n\n\n\n\nexport default class BreadthFirstSearch extends Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.handleClick = this.handleClick.bind(this);\n    this.handleExpandClick = this.handleExpandClick.bind(this);\n\n    this.state = {\n      hexSize: 20,\n      //position of the very middle hexagon (changes the numbers seen in hexagons)\n      //decreasing y moves hexagon(0,0,0) upwards, increasing x moves hexagon(0,0,0) to the right\n      hexOrigin: { x: 400, y: 300 },\n      currentHex: {q: 0, r: 0, s: 0, x: 0, y: 0},\n      playerPosition: {q: 0, r: 0, s: 0, x: 400, y: 300},\n      obstacles: DUMMY_OBSTACLES,\n      frontier: [],\n      //storing hexagons starting from playerPosition\n      cameFrom: {}\n    }\n  }\n  componentWillMount(){\n    let hexParametres = this.getHexParametres();\n    this.setState({\n      canvasSize: { canvasWidth: 800, canvasHeight: 600 },\n      hexParametres: hexParametres\n    })\n  }\n\n  componentDidMount(){\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    this.canvasHex.width = canvasWidth;\n    this.canvasHex.height = canvasHeight;\n    this.canvasInteraction.width = canvasWidth;\n    this.canvasInteraction.height = canvasHeight;\n    this.canvasView.width = canvasWidth;\n    this.canvasView.height = canvasHeight;\n    this.getCanvasPosition(this.canvasInteraction);\n    this.drawHex(this.canvasInteraction, this.Point(this.state.playerPosition.x, this.state.playerPosition.y), 1, \"grey\", \"red\", 0.2);\n    this.drawHexes();\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if(nextState.currentHex !== this.state.currentHex) {\n      const { q, r, s, x, y } = nextState.currentHex;\n      const { canvasWidth, canvasHeight } = this.state.canvasSize;\n      const ctx = this.canvasInteraction.getContext(\"2d\");\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n      let currentDistanceLine = nextState.currentDistanceLine;\n\n      for (let i = 0; i <= currentDistanceLine.length - 2; i++) {\n        if(i === 0) {\n          this.drawHex(this.canvasInteraction, this.Point(currentDistanceLine[i].x, currentDistanceLine[i].y), 1, \"black\", \"red\");\n        }else {\n          this.drawHex(this.canvasInteraction, this.Point(currentDistanceLine[i].x, currentDistanceLine[i].y), 1, \"black\", \"grey\");\n        }\n\n      }\n      nextState.obstacles.map((l)=>{\n        const { q, r, s } = JSON.parse(l);\n        const { x, y } = this.hexToPixel(this.Hex(q, r, s))\n        this.drawHex(this.canvasInteraction, this.Point(x, y), 1, \"black\", \"black\");\n\n      })\n      this.drawHex(this.canvasInteraction, this.Point(x, y), 1, \"black\", \"grey\");\n      return true;\n    }\n    if(nextState.cameFrom !== this.state.cameFrom) {\n      const { canvasWidth, canvasHeight } = this.state.canvasSize;\n      const ctx = this.canvasView.getContext(\"2d\");\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n      for(let l in nextState.cameFrom) {\n        const { q, r, s } = JSON.parse(l);\n        const { x, y } = this.hexToPixel(this.Hex(q, r));\n        this.drawHex(this.canvasView, this.Point(x, y), 1, \"black\", \"green\", 0.1);\n      }\n      return true;\n    }\n\n    return false;\n  }\n\n\n  drawHexes() {\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n    //calculate how many columns are on the left side\n    //hexOrigin is distance from coorindate x = 0 to hex0(middle hexagon)\n    const hexOrigin = this.state.hexOrigin;\n    //dividing the distance from the left side of border(x=0) by\n    //the width of a hexagon to calculate how many hexagons fit on left\n    let qLeftSide = Math.round(hexOrigin.x/horizDist);\n    //calculate how many hexagons will fit on the right\n    let qRightSide = Math.round((canvasWidth - hexOrigin.x)/horizDist);\n    let rTopSide = Math.round(hexOrigin.y/vertDist);\n    let rBottomSide = Math.round((canvasHeight - hexOrigin.y)/vertDist);\n    var p = 0;\n    //screenshot 1 - populates hexigons vertically (populates POSITIVE rows)\n    for(let r = 0; r <= rBottomSide; r++) {\n      if(r%2 === 0 && r !== 0) {\n        p++;\n      }\n      //populates hexigons horizontally in upper half (populates POSITIVE columns)\n      for(let q = -qLeftSide; q <= qRightSide; q++) {\n          const { x, y } = this.hexToPixel(this.Hex(q-p, r));\n          if((x > hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n            this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n            //passing in canvas and position of each hex(row, column)\n\n          }\n      }\n    }\n    var n = 0;\n    //screenshot 1 - populates hexigons vertically (populates NEGATIVE rows)\n    for(let r = -1; r >= -rTopSide; r--) {\n      if(r%2 !== 0) {\n        n++;\n      }\n      //populates hexigons horizontally in lower half (populates NEGATIVE columns)\n      for(let q = -qLeftSide; q <= qRightSide; q++) {\n          //adding integers to hexToPixel arguments shifts hexagons right\n          const { x, y } = this.hexToPixel(this.Hex(q+n, r));\n          if((x > hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n            this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n\n          }\n      }\n    }\n  }\n\n  //builds the individual hex shape\n  drawHex(canvasID, center, lineWidth, lineColor, fillColor) {\n    for(let i = 0; i <=5; i++) {\n      let start = this.getHexCornerCoord(center, i);\n      let end = this.getHexCornerCoord(center, i + 1);\n\n      this.fillHex(canvasID, center, fillColor);\n      this.drawLine(canvasID, start, end, lineWidth, lineColor);\n\n    }\n  }\n\n  //get the coordinates of the corner to draw the hex\n    getHexCornerCoord(center, i) {\n      var angle_deg = 60 * i + 30;\n      var angle_rad = Math.PI / 180 * angle_deg;\n      let x = center.x + this.state.hexSize * Math.cos(angle_rad);\n      let y = center.y + this.state.hexSize * Math.sin(angle_rad);\n      return this.Point(x, y);\n    }\n\n    Hex(q, r, s) {\n      return {q: q, r: r, s: s}\n    }\n\n    Point(x, y) {\n      return {x: x, y: y}\n    }\n\n//draws the line that shapes the hex\n  drawLine(canvasID, start, end, lineWidth, lineColor) {\n    const ctx = canvasID.getContext(\"2d\");\n    ctx.beginPath();\n    ctx.moveTo(start.x, start.y);\n    ctx.strokeStyle = lineColor;\n    ctx.lineWidth = lineWidth;\n    ctx.lineTo(end.x, end.y);\n    ctx.stroke();\n    ctx.closePath();\n  }\n\n  fillHex(canvasID, center, fillColor) {\n    let c0 = this.getHexCornerCoord(center, 0);\n    let c1 = this.getHexCornerCoord(center, 1);\n    let c2 = this.getHexCornerCoord(center, 2);\n    let c3 = this.getHexCornerCoord(center, 3);\n    let c4 = this.getHexCornerCoord(center, 4);\n    let c5 = this.getHexCornerCoord(center, 5);\n    const ctx = canvasID.getContext(\"2d\");\n    ctx.beginPath();\n    ctx.fillStyle = fillColor;\n    ctx.globalAlpha = 0.1;\n    ctx.moveTo(c0.x, c0.y);\n    ctx.lineTo(c1.x, c1.y);\n    ctx.lineTo(c2.x, c2.y);\n    ctx.lineTo(c3.x, c3.y);\n    ctx.lineTo(c4.x, c4.y);\n    ctx.lineTo(c5.x, c5.y);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n//prints the coordinates inside of the hexagons\n  drawHexCoordinates(canvasID, center, h) {\n    const ctx = canvasID.getContext(\"2d\");\n    ctx.fillText(h.q, center.x+6, center.y);\n    ctx.fillText(h.r, center.x-3, center.y+15);\n    ctx.fillText(h.s, center.x-12, center.y);\n  }\n\n\n\n  getHexParametres() {\n    let hexHeight = this.state.hexSize * 2;\n    let hexWidth = Math.sqrt(3)/2 * hexHeight;\n    //vertical distance between hexigons in each row\n    let vertDist = hexHeight * 3/4;\n    let horizDist = hexWidth;\n    return { hexWidth, hexHeight, vertDist, horizDist }\n  }\n\n  hexToPixel(h) {\n    //can change where the bundle of hexes originates on the whole grid\n    let hexOrigin = this.state.hexOrigin;\n    let x = this.state.hexSize * Math.sqrt(3) * (h.q + h.r/2) + hexOrigin.x;\n    let y = this.state.hexSize * 3/2 * h.r + hexOrigin.y;\n    return this.Point(x, y)\n  }\n\n  pixelToHex(p) {\n    let size = this.state.hexSize;\n    let origin = this.state.hexOrigin;\n    let q = ((p.x - origin.x) * Math.sqrt(3)/3 - (p.y - origin.y) / 3) / size\n    let r = (p.y - origin.y) * 2/3 / size\n    return this.Hex(q, r, -q - r);\n  }\n\n  getDistanceLine(hexA, hexB) {\n    let dist = this.cubeDistance(hexA, hexB);\n    var arr = [];\n    for(let i = 0; i <= dist; i++) {\n     let center = this.hexToPixel(this.cubeRound(this.cubeLinearInt(hexA, hexB, 1.0 / dist * i)));\n     arr = [].concat(arr, center);\n    }\n    this.setState({\n      currentDistanceLine: arr\n    })\n  }\n\n\n\n  cubeDirection(direction) {\n    const cubeDirections = [this.Hex(1, 0, -1), this.Hex(1, -1, 0), this.Hex(0, -1, 1),\n    this.Hex(-1, 0, 1), this.Hex(-1, 1, 0), this.Hex(0, 1, -1)];\n    return cubeDirections[direction];\n  }\n\n  cubeLinearInt(hexA, hexB, t) {\n    return this.Hex(this.linearInt(hexA.q, hexB.q, t), this.linearInt(hexA.r, hexB.r, t),\n    this.linearInt(hexA.s, hexB.s, t));\n  }\n\n  linearInt(a, b, t) {\n    return (a + (b - a) * t)\n  }\n\n  cubeAdd(a, b) {\n    return this.Hex(a.q + b.q, a.r + b.r, a.s + b.s);\n  }\n\n  cubeSubstract(hexA, hexB) {\n    return this.Hex(hexA.q - hexB.q, hexA.r - hexB.r, hexA.s - hexB.s);\n  }\n\n  getCubeNeighbor(h, direction) {\n    return this.cubeAdd(h, this.cubeDirection(direction));\n  }\n\n  getNeighbors(h) {\n    var arr = [];\n    for(let i = 0; i <=5; i++) {\n      const { q, r, s } = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n      arr.push(this.Hex(q, r, s));\n    }\n    return arr;\n  }\n\n\n\n  cubeRound(cube) {\n    var rx = Math.round(cube.q)\n    var ry = Math.round(cube.r)\n    var rz = Math.round(cube.s)\n    var x_diff = Math.abs(rx - cube.q)\n    var y_diff = Math.abs(ry - cube.r)\n    var z_diff = Math.abs(rz - cube.s)\n    if(x_diff > y_diff && x_diff > z_diff) {\n      rx = -ry-rz\n    }\n    else if(y_diff > z_diff) {\n      ry = -rx-rz\n    }\n    else{\n      rz = -rx-ry\n    }\n    return this.Hex(rx, ry, rz)\n  }\n\n\n\n  cubeDistance(hexA, hexB) {\n    const { q, r, s } = this.cubeSubstract(hexA, hexB);\n    return (Math.abs(q) + Math.abs(r) + Math.abs(s)) / 2;\n  }\n\n\n  drawNeighbors(h) {\n    for(let i = 0; i <= 5; i++) {\n      const { q, r, s } = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n      const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n      this.drawHex(this.canvasInteraction, this.Point(x, y), \"red\", 2);\n    }\n  }\n\n\n    getCanvasPosition(canvasID) {\n      let rect = canvasID.getBoundingClientRect();\n      this.setState({\n         canvasPosition: { left:rect.left, right: rect.right, top: rect.top, bottom: rect.bottom }\n      })\n    }\n\n  handleMouseMove(e) {\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n    //const { left, right, top, bottom } = this.state.canvasPosition;\n    //changing the number at the end affects result exponentially\n    var canvasPos = document.getElementById(\"canv3\");\n    let rect = canvasPos.getBoundingClientRect();\n    let offsetX = e.pageX - rect.left;\n    let offsetY = (e.pageY - (window.pageYOffset + rect.top));\n\n\n\n\n\n\n    const { q, r, s } = this.cubeRound(this.pixelToHex(this.Point(offsetX, offsetY)));\n    const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n\n   let playerPosition = this.state.playerPosition;\n\n\n    this.getDistanceLine(this.Hex(0,0,0), this.Hex(q,r,s));\n\n    if((x > hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n      this.setState({\n        currentHex: {q, r, s, x, y}\n      })\n    }\n\n  }\n\n  handleClick() {\n    this.addObstacles();\n  }\n\n  addObstacles() {\n    const { q, r, s } = this.state.currentHex;\n    let obstacles = this.state.obstacles;\n    if(!obstacles.includes(JSON.stringify(this.Hex(q, r, s)))) {\n      obstacles = [].concat(obstacles, JSON.stringify(this.Hex(q, r, s)))\n    } else {\n      obstacles.map((l,i) => {\n        if(l === JSON.stringify(this.Hex(q, r, s))) {\n          obstacles = obstacles.slice(0, i).concat(obstacles.slice(i+1));\n        }\n      })\n    }\n    console.log({\"q\":q, \"r\":r, \"s\":s})\n    this.setState({\n      obstacles: obstacles\n    })\n  }\n\n  handleExpandClick() {\n    var frontier = this.state.frontier;\n    var cameFrom = this.state.cameFrom;\n    if(frontier == 0) {\n      frontier.push(this.Hex(0,0,0));\n      cameFrom[JSON.stringify(this.Hex(0,0,0))] = JSON.stringify(null);\n    }\n    let n = 0;\n    while(n < 1) {\n      var current = frontier.shift();\n      let arr = this.getNeighbors(current);\n      arr.map((l) => {\n        if(!cameFrom.hasOwnProperty(JSON.stringify(l)) && !this.state.obstacles.includes(JSON.stringify(l))) {\n          frontier.push(l);\n          cameFrom[JSON.stringify(l)] = JSON.stringify(current);\n        }\n      })\n      n++\n    }\n    cameFrom = Object.assign({}, cameFrom);\n    this.setState({\n      cameFrom: cameFrom\n    })\n  }\n\n  resetSketch() {\n  window.location.reload();\n  }\n\n\nrender() {\n    return (\n      <section id=\"BFS\">\n        <div className=\"description25\">\n        <b id='bold'>Real World Application:</b><br/>\n        - The BFS algorithm is taught as a common algorithm to computer science students.<br/>\n        - It can be used to solve multiple graph theory problems.<br/>\n        <b id=\"bold\">How to use:</b> Hit expand to see Breadth First Search carried out starting\n          from the middle node.<br/>\n\n        </div>\n\n          <button\n              className=\"reset1\"\n              onClick={ this.resetSketch }\n              style= {{ textAlign: \"center\" }}\n            >\n              Reset\n            </button>\n\n            <button\n              className=\"expandButton1\"\n              color=\"blue\"\n              style={{textAlign: \"center\"}}\n              onClick={this.handleExpandClick}>\n              Expand\n            </button>\n\n            <br></br>\n        <canvas id=\"canv4\" ref={canvasHex => this.canvasHex = canvasHex }> </canvas>\n        <canvas id=\"canv3\" ref={canvasCoordinates => this.canvasCoordinates = canvasCoordinates }> </canvas>\n        <canvas id=\"canv2\" ref={canvasView => this.canvasView = canvasView }> </canvas>\n        <canvas id=\"canv1\" ref={canvasInteraction => this.canvasInteraction = canvasInteraction} onMouseMove = {this.handleMouseMove} onClick = {this.handleClick}> </canvas>\n    </section>\n    )\n  }\n}","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS2.js",["79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99"],"import React, {Component} from 'react';\n\nvar DUMMY_OBSTACLES = ['{\"q\":4,\"r\":-2,\"s\":-2}', \n'{\"q\":4,\"r\":-1,\"s\":-3}', '{\"q\":4,\"r\":0,\"s\":-4}', \n'{\"q\":4,\"r\":1,\"s\":-5}', '{\"q\":3,\"r\":2,\"s\":-5}', \n'{\"q\":2,\"r\":3,\"s\":-5}', '{\"q\":1,\"r\":4,\"s\":-5}', \n'{\"q\":0,\"r\":5,\"s\":-5}', '{\"q\":-1,\"r\":6,\"s\":-5}', \n'{\"q\":-2,\"r\":7,\"s\":-5}', '{\"q\":4,\"r\":-4,\"s\":0}', \n'{\"q\":3,\"r\":-4,\"s\":1}', '{\"q\":2,\"r\":-4,\"s\":2}', \n'{\"q\":1,\"r\":-4,\"s\":3}', '{\"q\":2,\"r\":-5,\"s\":3}', \n'{\"q\":3,\"r\":-6,\"s\":3}', '{\"q\":4,\"r\":-7,\"s\":3}', \n'{\"q\":5,\"r\":-9,\"s\":4}', '{\"q\":6,\"r\":-9,\"s\":3}', \n'{\"q\":7,\"r\":-9,\"s\":2}', '{\"q\":8,\"r\":-9,\"s\":1}', \n'{\"q\":9,\"r\":-9,\"s\":0}', '{\"q\":10,\"r\":-9,\"s\":-1}', \n'{\"q\":11,\"r\":-9,\"s\":-2}', '{\"q\":12,\"r\":-9,\"s\":-3}', \n'{\"q\":13,\"r\":-9,\"s\":-4}', '{\"q\":14,\"r\":-9,\"s\":-5}', \n'{\"q\":15,\"r\":-9,\"s\":-6}', '{\"q\":15,\"r\":-8,\"s\":-7}', \n'{\"q\":14,\"r\":-7,\"s\":-7}', '{\"q\":14,\"r\":-6,\"s\":-8}', \n'{\"q\":13,\"r\":-5,\"s\":-8}', '{\"q\":13,\"r\":-4,\"s\":-9}', \n'{\"q\":12,\"r\":-3,\"s\":-9}', '{\"q\":12,\"r\":-2,\"s\":-10}', \n'{\"q\":11,\"r\":-1,\"s\":-10}', '{\"q\":11,\"r\":0,\"s\":-11}', \n'{\"q\":10,\"r\":1,\"s\":-11}', '{\"q\":10,\"r\":2,\"s\":-12}', \n'{\"q\":9,\"r\":3,\"s\":-12}', '{\"q\":9,\"r\":4,\"s\":-13}', \n'{\"q\":8,\"r\":5,\"s\":-13}', '{\"q\":8,\"r\":6,\"s\":-14}', \n'{\"q\":7,\"r\":7,\"s\":-14}', '{\"q\":7,\"r\":8,\"s\":-15}', \n'{\"q\":6,\"r\":9,\"s\":-15}', '{\"q\":5,\"r\":9,\"s\":-14}', \n'{\"q\":4,\"r\":9,\"s\":-13}', '{\"q\":3,\"r\":9,\"s\":-12}', \n'{\"q\":2,\"r\":9,\"s\":-11}', '{\"q\":1,\"r\":9,\"s\":-10}', \n'{\"q\":0,\"r\":9,\"s\":-9}', '{\"q\":-1,\"r\":9,\"s\":-8}', \n'{\"q\":-2,\"r\":9,\"s\":-7}', '{\"q\":-3,\"r\":9,\"s\":-6}', \n'{\"q\":-4,\"r\":9,\"s\":-5}', '{\"q\":-5,\"r\":9,\"s\":-4}', \n'{\"q\":-5,\"r\":8,\"s\":-3}', '{\"q\":-5,\"r\":7,\"s\":-2}', \n'{\"q\":-5,\"r\":6,\"s\":-1}', '{\"q\":-5,\"r\":5,\"s\":0}', \n'{\"q\":-4,\"r\":4,\"s\":0}', '{\"q\":-3,\"r\":3,\"s\":0}', \n'{\"q\":-2,\"r\":-1,\"s\":3}', '{\"q\":-2,\"r\":-2,\"s\":4}', \n'{\"q\":-4,\"r\":1,\"s\":3}', '{\"q\":-4,\"r\":2,\"s\":2}', \n'{\"q\":-5,\"r\":3,\"s\":2}', '{\"q\":-7,\"r\":4,\"s\":3}', \n'{\"q\":-6,\"r\":4,\"s\":2}', '{\"q\":-8,\"r\":4,\"s\":4}', \n'{\"q\":-9,\"r\":4,\"s\":5}', '{\"q\":-10,\"r\":4,\"s\":6}', \n'{\"q\":-11,\"r\":4,\"s\":7}', '{\"q\":-12,\"r\":4,\"s\":8}', \n'{\"q\":-12,\"r\":2,\"s\":10}', '{\"q\":-12,\"r\":3,\"s\":9}', \n'{\"q\":-13,\"r\":4,\"s\":9}', '{\"q\":-13,\"r\":5,\"s\":8}', \n'{\"q\":-14,\"r\":6,\"s\":8}', '{\"q\":-14,\"r\":7,\"s\":7}', \n'{\"q\":-15,\"r\":8,\"s\":7}', '{\"q\":-15,\"r\":9,\"s\":6}', \n'{\"q\":-14,\"r\":9,\"s\":5}', '{\"q\":-13,\"r\":9,\"s\":4}', \n'{\"q\":-12,\"r\":9,\"s\":3}', '{\"q\":-11,\"r\":9,\"s\":2}', \n'{\"q\":-10,\"r\":9,\"s\":1}', '{\"q\":-9,\"r\":9,\"s\":0}', \n'{\"q\":-8,\"r\":9,\"s\":-1}', '{\"q\":-7,\"r\":9,\"s\":-2}', \n'{\"q\":-6,\"r\":9,\"s\":-3}', '{\"q\":-11,\"r\":1,\"s\":10}', \n'{\"q\":-11,\"r\":0,\"s\":11}', '{\"q\":-10,\"r\":-1,\"s\":11}', \n'{\"q\":-10,\"r\":-2,\"s\":12}', '{\"q\":-9,\"r\":-3,\"s\":12}', \n'{\"q\":-9,\"r\":-4,\"s\":13}', '{\"q\":-8,\"r\":-5,\"s\":13}', \n'{\"q\":-8,\"r\":-6,\"s\":14}', '{\"q\":-7,\"r\":-7,\"s\":14}', \n'{\"q\":-7,\"r\":-8,\"s\":15}', '{\"q\":-6,\"r\":-9,\"s\":15}', \n'{\"q\":-5,\"r\":-9,\"s\":14}', '{\"q\":-4,\"r\":-9,\"s\":13}', \n'{\"q\":-3,\"r\":-9,\"s\":12}', '{\"q\":-2,\"r\":-9,\"s\":11}', \n'{\"q\":-1,\"r\":-9,\"s\":10}', '{\"q\":0,\"r\":-9,\"s\":9}', \n'{\"q\":1,\"r\":-9,\"s\":8}', '{\"q\":2,\"r\":-9,\"s\":7}', \n'{\"q\":3,\"r\":-9,\"s\":6}', '{\"q\":4,\"r\":-9,\"s\":5}', \n'{\"q\":-2,\"r\":-8,\"s\":10}', '{\"q\":-3,\"r\":-7,\"s\":10}', \n'{\"q\":-4,\"r\":-6,\"s\":10}', '{\"q\":-5,\"r\":-5,\"s\":10}', \n'{\"q\":-6,\"r\":-4,\"s\":10}', '{\"q\":-7,\"r\":-4,\"s\":11}', \n'{\"q\":-6,\"r\":-2,\"s\":8}', '{\"q\":-6,\"r\":-1,\"s\":7}', \n'{\"q\":-6,\"r\":0,\"s\":6}', '{\"q\":-6,\"r\":1,\"s\":5}', \n'{\"q\":7,\"r\":-2,\"s\":-5}', '{\"q\":8,\"r\":-2,\"s\":-6}', \n'{\"q\":9,\"r\":-3,\"s\":-6}', '{\"q\":10,\"r\":-3,\"s\":-7}', \n'{\"q\":4,\"r\":5,\"s\":-9}', '{\"q\":4,\"r\":6,\"s\":-10}', \n'{\"q\":5,\"r\":6,\"s\":-11}', '{\"q\":5,\"r\":7,\"s\":-12}']\n\n\nexport default class BFSExtra extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.handleClick = this.handleClick.bind(this);\n    //possibly but this.breadthFirstSearch = this.breadthfirstsearch.bind(this)\n\n\n    this.state = {\n      hexSize: 20,\n      //position of the very middle hexagon (changes the numbers seen in hexagons)\n      //decreasing y moves hexagon(0,0,0) upwards, increasing x moves hexagon(0,0,0) to the right\n      hexOrigin: { x: 400, y: 300 },\n      currentHex: {q: 0, r: 0, s: 0, x: 0, y: 0},\n      playerPosition: { q: 0, r: 0, s: 0 },\n      obstacles: DUMMY_OBSTACLES,\n      cameFrom: {},\n      hexPathMap: [],\n      path: []\n    }\n  }\n  componentWillMount(){\n    let hexParametres =  this.getHexParametres();\n    this.setState({\n      canvasSize: { canvasWidth: 800, canvasHeight: 600 },\n      hexParametres: hexParametres\n    })\n  }\n\n  componentDidMount(){\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    this.canvasHex.width = canvasWidth;\n    this.canvasHex.height = canvasHeight;\n    this.canvasInteraction.width = canvasWidth;\n    this.canvasInteraction.height = canvasHeight;\n    this.canvasView.width = canvasWidth;\n    this.canvasView.height = canvasHeight;\n    this.getCanvasPosition(this.canvasInteraction);\n    this.drawHex(this.canvasInteraction, this.Point(this.state.playerPosition.x, this.state.playerPosition.y), 1, \"grey\", \"red\", 0.2);\n    this.drawHexes();\n    this.drawObstacles();\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if(nextState.currentHex !== this.state.currentHex) {\n  const { q, r, s, x, y } = nextState.currentHex;\n  const { canvasWidth, canvasHeight } = this.state.canvasSize;\n  const ctx = this.canvasInteraction.getContext(\"2d\");\n  ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n  /*this.drawNeighbors(this.Hex(q, r, s));*/\n  this.drawPath();\n  return true;\n}\n  if(nextState.cameFrom !== this.state.cameFrom) {\n  const { canvasWidth, canvasHeight } = this.state.canvasSize;\n  const ctx = this.canvasView.getContext(\"2d\");\n  ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n  for (let l in nextState.cameFrom) {\n    const { q, r, s } = JSON.parse(l);\n    const { x, y } = this.hexToPixel(this.Hex(q, r));\n    this.drawHex(this.canvasView, this.Point(x, y), 1, \"black\", \"green\", 0.1);\n    var from = JSON.parse(nextState.cameFrom[l]);\n    var fromCoord = this.hexToPixel(this.Hex(from.q, from.r));\n    this.drawArrow(fromCoord.x, fromCoord.y, x, y);\n  }\n  return true;\n  }\n  return false;\n  }\n\n\n  drawHexes() {\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n  const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n  const hexOrigin = this.state.hexOrigin;\n  let qLeftSide = Math.round(hexOrigin.x/horizDist);\n  let qRightSide = Math.round((canvasWidth - hexOrigin.x)/horizDist);\n  let rTopSide = Math.round(hexOrigin.y/vertDist);\n  let rBottomSide = Math.round((canvasHeight - hexOrigin.y)/vertDist);\n  var hexPathMap = [];\n  var p = 0;\n  for (let r = 0; r <= rBottomSide; r++) {\n    if(r%2 == 0 && r !==0) {\n      p++;\n    }\n    for (let q = -qLeftSide; q <= qRightSide; q++) {\n        const { x, y } = this.hexToPixel(this.Hex(q-p, r));\n        if ((x >hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n          this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n          /*this.drawHexCoordinates(this.canvasHex, this.Point(x,y), this.Hex(q-p, r, -(q - p) - r));*/\n          var bottomH = JSON.stringify(this.Hex(q-p, r, -(q - p) - r));\n          if(!this.state.obstacles.includes(bottomH)) {\n            hexPathMap.push(bottomH);\n          }\n        }\n    }\n  }\nvar n = 0;\n  for (let r = -1; r >= -rTopSide; r--) {\n    if(r%2 !== 0) {\n      n++;\n    }\n    for (let q = -qLeftSide; q <= qRightSide; q++) {\n        const { x, y } = this.hexToPixel(this.Hex(q+n, r));\n          if ((x >hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n        this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n        /*this.drawHexCoordinates(this.canvasHex, this.Point(x,y), this.Hex(q+n, r, - (q + n) - r));*/\n        var topH = JSON.stringify(this.Hex(q+n, r, - (q + n) - r));\n        if(!this.state.obstacles.includes(topH)) {\n          hexPathMap.push(topH);\n        }\n      }\n    }\n  }\n  hexPathMap = [].concat(hexPathMap);\n  this.setState(\n    {hexPathMap: hexPathMap},\n    this.breadthFirstSearchCallback = () => this.breadthFirstSearch(this.state.playerPosition)\n  )\n  }\n\n  //builds the individual hex shape\n  drawHex(canvasID, center, lineWidth, lineColor, fillColor) {\n  for (let i = 0; i <= 5; i++) {\n    let start = this.getHexCornerCoord(center, i);\n    let end = this.getHexCornerCoord(center, i + 1);\n    this.fillHex(canvasID, center, fillColor);\n    this.drawLine(canvasID, start, end, lineWidth, lineColor);\n  }\n}\n\n  //get the coordinates of the corner to draw the hex\n  getHexCornerCoord(center, i) {\n   let angle_deg = 60 * i   + 30;\n   let angle_rad = Math.PI / 180 * angle_deg;\n   let x = center.x + this.state.hexSize * Math.cos(angle_rad);\n  let y = center.y + this.state.hexSize * Math.sin(angle_rad);\n  return this.Point(x, y);\n }\n\n getHexParametres() {\n  let hexHeight = this.state.hexSize * 2;\n  let hexWidth = Math.sqrt(3)/2 * hexHeight;\n  let vertDist = hexHeight * 3/4;\n  let horizDist = hexWidth;\n  return { hexWidth, hexHeight, vertDist, horizDist }\n}\n\ngetCanvasPosition(canvasID) {\n  let rect = canvasID.getBoundingClientRect();\n  this.setState({\n    canvasPosition: { left:rect.left, right: rect.right, top: rect.top, bottom: rect.bottom }\n  })\n}\n   hexToPixel(h) {\n     let hexOrigin = this.state.hexOrigin;\n     let x = this.state.hexSize * Math.sqrt(3) * (h.q + h.r/2) + hexOrigin.x;\n     let y = this.state.hexSize * 3/2 * h.r + hexOrigin.y;\n     return this.Point(x, y)\n   }\n   pixelToHex(p) {\n     let size = this.state.hexSize;\n     let origin = this.state.hexOrigin;\n     let q = ((p.x - origin.x) * Math.sqrt(3)/3 - (p.y - origin.y) / 3) / size\n     let r = (p.y - origin.y) * 2/3 / size\n     return this.Hex(q, r, - q - r);\n   }\ncubeDirection(direction) {\n  const cubeDirections = [this.Hex(1, 0, -1), this.Hex(1, -1, 0), this.Hex(0, -1, 1),\n                          this.Hex(-1, 0, 1), this.Hex(-1, 1, 0), this.Hex(0, 1, -1)];\nreturn cubeDirections[direction];\n}\ncubeAdd(a, b) {\n  return this.Hex(a.q + b.q, a.r + b.r, a.s + b.s);\n}\ncubeSubstract(hexA, hexB) {\n  return this.Hex(hexA.q - hexB.q, hexA.r - hexB.r, hexA.s - hexB.s);\n}\ngetCubeNeighbor(h, direction) {\n  return this.cubeAdd(h, this.cubeDirection(direction));\n}\ngetNeighbors(h) {\n  var arr = [];\n  for (let i = 0; i <= 5; i++) {\n    const { q, r, s } = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n    arr.push(this.Hex(q, r, s));\n  }\n  return arr;\n}\n   cubeRound(cube) {\n     var rx = Math.round(cube.q)\n     var ry = Math.round(cube.r)\n     var rz = Math.round(cube.s)\n     var x_diff = Math.abs(rx - cube.q)\n     var y_diff = Math.abs(ry - cube.r)\n     var z_diff = Math.abs(rz - cube.s)\n     if (x_diff > y_diff && x_diff > z_diff) {\n       rx = -ry-rz;\n     } else if (y_diff > z_diff) {\n          ry = -rx-rz\n     } else {\n          rz = -rx-ry\n     }\n     return this.Hex(rx, ry, rz)\n   }\ngetDistanceLine(hexA, hexB) {\n  let dist = this.cubeDistance(hexA, hexB);\n  var arr = [];\n  for (let i = 0; i <= dist; i++) {\n  let center = this.hexToPixel(this.cubeRound(this.cubeLinearInt(hexA, hexB, 1.0 / dist * i)));\n  arr = [].concat(arr, center);\n  }\n  this.setState({\n    currentDistanceLine: arr\n  })\n}\ncubeDistance(hexA, hexB) {\n  const { q, r, s } = this.cubeSubstract(hexA, hexB);\n  return (Math.abs(q) + Math.abs(r) + Math.abs(s)) / 2;\n}\ncubeLinearInt(hexA, hexB, t) {\n  return this.Hex(this.linearInt(hexA.q, hexB.q, t), this.linearInt(hexA.r, hexB.r, t), this.linearInt(hexA.s, hexB.s, t));\n}\nlinearInt(a, b, t) {\n    return (a + (b - a) * t)\n}\nPoint(x, y) {\n     return {x: x, y: y}\n   }\n   Hex(q, r, s) {\n     return {q: q, r: r, s: s}\n   }\n   drawLine(canvasID, start, end, lineWidth, lineColor) {\n     const ctx = canvasID.getContext(\"2d\");\n     ctx.beginPath();\n     ctx.moveTo(start.x, start.y);\n     ctx.strokeStyle = lineColor;\n     ctx.lineWidth = lineWidth;\n     ctx.lineTo(end.x, end.y);\n     ctx.stroke();\n     ctx.closePath();\n   }\n\n   fillHex(canvasID, center, fillColor) {\n     let c0 = this.getHexCornerCoord(center, 0);\n     let c1 = this.getHexCornerCoord(center, 1);\n     let c2 = this.getHexCornerCoord(center, 2);\n     let c3 = this.getHexCornerCoord(center, 3);\n     let c4 = this.getHexCornerCoord(center, 4);\n     let c5 = this.getHexCornerCoord(center, 5);\n     const ctx = canvasID. getContext(\"2d\");\n     ctx.beginPath();\n     ctx.fillStyle = fillColor;\n     ctx.globalAlpha = 0.1;\n     ctx.moveTo(c0.x, c0.y);\n     ctx.lineTo(c1.x, c1.y);\n     ctx.lineTo(c2.x, c2.y);\n     ctx.lineTo(c3.x, c3.y);\n     ctx.lineTo(c4.x, c4.y);\n     ctx.lineTo(c5.x, c5.y);\n     ctx.closePath();\n     ctx.fill();\n   }\n   drawHexCoordinates(canvasID, center, h) {\n     const ctx = canvasID.getContext(\"2d\");\n     ctx.fillText(h.q, center.x+6, center.y);\n     ctx.fillText(h.r, center.x-3, center.y+15);\n     ctx.fillText(h.s, center.x-12, center.y);\n   }\ndrawNeighbors(h) {\n  for (let i = 0; i <= 5; i++) {\n    const { q, r, s} = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n    const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n    this.drawHex(this.canvasInteraction, this.Point(x, y), \"red\", 2);\n  }\n}\n\nhandleMouseMove(e) {\n     const { canvasWidth, canvasHeight } = this.state.canvasSize;\n     const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n     const { left, right, top, bottom } = this.state.canvasPosition;\n     var canvasPos = document.getElementById(\"canv7\");\n     let rect = canvasPos.getBoundingClientRect();\n     let offsetX = e.pageX - rect.left;\n     let offsetY = (e.pageY - (window.pageYOffset + rect.top));\n     const { q, r, s } = this.cubeRound(this.pixelToHex(this.Point(offsetX, offsetY)));\n     const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n     let playerPosition = this.state.playerPosition;\n     this.getDistanceLine(this.Hex(0,0,0), this.Hex(q,r,s));\n     /*this.getDistanceLine(this.Hex(0,0,0), this.Hex(q,r,s));*/\n     this.getPath(this.Hex(playerPosition.q, playerPosition.r, playerPosition.s), this.Hex(q,r,s));\n      if ((x >hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\nthis.setState({\n  currentHex: {q, r, s, x, y}\n})\n}\n   }\n\n   getPath(start, current) {\n  const { cameFrom } = this.state;\n  start = JSON.stringify(start);\n  current = JSON.stringify(current);\n  if(cameFrom[current] != undefined) {\n    var path = [current];\n    while (current != start) {\n      current = cameFrom[current];\n      path.push(current);\n    }\n    path = [].concat(path);\n    this.setState({\n      path: path\n    })\n  }\n}\n\ndrawPath() {\nlet path = this.state.path;\nfor (let i = 0; i <= path.length - 1; i++) {\n  const {q,r} = JSON.parse(path[i]);\n  const {x,y} = this.hexToPixel(this.Hex(q,r));\n  this.drawHex(this.canvasInteraction, this.Point(x,y), 1, \"black\", \"red\");\n}\n}\n\ndrawArrow(fromx, fromy, tox, toy){\n                var ctx = this.canvasView.getContext(\"2d\");\n                var headlen = 5;\n                var angle = Math.atan2(toy-fromy,tox-fromx);\n                ctx.beginPath();\n                ctx.moveTo(fromx, fromy);\n                ctx.lineTo(tox, toy);\n                ctx.strokeStyle = \"#cc0000\";\n                ctx.lineWidth = 3;\n                ctx.stroke();\n                ctx.beginPath();\n                ctx.moveTo(tox, toy);\n                ctx.globalAlpha = 0.3;\n                ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));\n                ctx.lineTo(tox-headlen*Math.cos(angle+Math.PI/7),toy-headlen*Math.sin(angle+Math.PI/7));\n                ctx.lineTo(tox, toy);\n                ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));\n                ctx.strokeStyle = \"#cc0000\";\n                ctx.lineWidth = 5;\n                ctx.stroke();\n                ctx.fillStyle = \"#cc0000\";\n                ctx.fill();\n            }\n\n            handleClick() {\n\nconst { currentHex, cameFrom } = this.state;\nconst { q,r,s } = currentHex;\nif(cameFrom[JSON.stringify(this.Hex(q,r,s))]) {\n  this.setState(\n    {playerPosition: this.Hex(q,r,s)},\n    this.breadthFirstSearchCallback = () => this.breadthFirstSearch(this.state.playerPosition)\n  )\n}\n   }\n\n   drawObstacles() {\n  this.state.obstacles.map((l) => {\n    const {q,r,s} = JSON.parse(l);\n    const {x,y} = this.hexToPixel(this.Hex(q,r,s));\n    this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"black\");\n  })\n}\n\nbreadthFirstSearch(playerPosition) {\nvar frontier = [playerPosition];\nvar cameFrom = {};\ncameFrom[JSON.stringify(playerPosition)] = JSON.stringify(playerPosition);\nwhile (frontier.length != 0) {\n  var current = frontier.shift();\n  let arr = this.getNeighbors(current);\n  arr.map((l) => {\n\n    if(!cameFrom.hasOwnProperty(JSON.stringify(l)) && this.state.hexPathMap.includes(JSON.stringify(l))) {\n      frontier.push(l);\n      cameFrom[JSON.stringify(l)] = JSON.stringify(current);\n    }\n  })\n\n}\ncameFrom = Object.assign({}, cameFrom);\nthis.setState({\n  cameFrom: cameFrom\n})\n}\n\n\n\n  resetSketch() {\n  window.location.reload();\n  }\n\n\nrender() {\n    return (\n      <div className=\"BFSExtra\">\n        <div className=\"title2\">\n        Breadth First Search\n        </div>\n        <div className=\"description2\">\n        <b id=\"bold\">What is it? </b>\n        <br/>\n        Breadth-First Search is an algorithm for traversing or searching tree or graph data structures.<br/>\n        It starts at the tree root and explores all of the neighboring nodes at the present depth before <br/>\n        moving on to the nodes at the next depth level.<br/>\n        \n        <br/>\n          <b id=\"bold\">How to use: </b>        <br/>\n        Click different areas of the board to see how BFS algorithm finds the shortest path!<br></br>\n          <br/>\n\n          <b id=\"bold\">How it works:</b><br/>\n        The shortest path is being calculated live by giving a distance value to every<br></br>\n        node on the board. The red arrows indicate the path that the algorithm is taking\n        from node to node.<br></br>\n        *View the second board below to see how the shortest path is determined step by step.<br/>\n        </div>\n        <canvas id=\"canv8\" ref={canvasHex => this.canvasHex = canvasHex }> </canvas>\n        <canvas id=\"canv7\" ref={canvasCoordinates => this.canvasCoordinates = canvasCoordinates }> </canvas>\n        <canvas id=\"canv6\" ref={canvasView => this.canvasView = canvasView }> </canvas>\n        <canvas id=\"canv5\" ref={canvasInteraction => this.canvasInteraction = canvasInteraction} onMouseMove = {this.handleMouseMove} onClick={this.handleClick}> </canvas>\n\n    </div>\n    )\n\n  }\n\n}","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BubbleSort/BubbleSort.js",["100","101"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/QuickSort/QuickSort.js",["102","103","104","105"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Router.js",["106"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Navbar.js",["107"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/A*Star/A_star.js",["108"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Traveling_Salesperson/TravelingSalesperson.js",["109"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/HomePage/HomePage.js",["110"],{"ruleId":"111","replacedBy":"112"},{"ruleId":"113","replacedBy":"114"},{"ruleId":"115","severity":1,"message":"116","line":142,"column":15,"nodeType":"117","messageId":"118","endLine":142,"endColumn":16},{"ruleId":"115","severity":1,"message":"119","line":142,"column":18,"nodeType":"117","messageId":"118","endLine":142,"endColumn":19},{"ruleId":"115","severity":1,"message":"120","line":142,"column":21,"nodeType":"117","messageId":"118","endLine":142,"endColumn":22},{"ruleId":"121","severity":1,"message":"122","line":157,"column":34,"nodeType":"123","messageId":"124","endLine":157,"endColumn":36},{"ruleId":"115","severity":1,"message":"120","line":171,"column":23,"nodeType":"117","messageId":"118","endLine":171,"endColumn":24},{"ruleId":"115","severity":1,"message":"125","line":423,"column":34,"nodeType":"117","messageId":"118","endLine":423,"endColumn":42},{"ruleId":"115","severity":1,"message":"126","line":423,"column":44,"nodeType":"117","messageId":"118","endLine":423,"endColumn":53},{"ruleId":"115","severity":1,"message":"127","line":439,"column":8,"nodeType":"117","messageId":"118","endLine":439,"endColumn":22},{"ruleId":"121","severity":1,"message":"122","line":462,"column":27,"nodeType":"123","messageId":"124","endLine":462,"endColumn":29},{"ruleId":"128","severity":1,"message":"129","line":477,"column":17,"nodeType":"130","messageId":"131","endLine":477,"endColumn":19},{"ruleId":"132","severity":1,"message":"133","line":485,"column":15,"nodeType":"123","messageId":"134","endLine":490,"endColumn":8},{"ruleId":"121","severity":1,"message":"122","line":485,"column":19,"nodeType":"123","messageId":"124","endLine":485,"endColumn":21},{"ruleId":"115","severity":1,"message":"135","line":1,"column":16,"nodeType":"117","messageId":"118","endLine":1,"endColumn":25},{"ruleId":"115","severity":1,"message":"116","line":116,"column":11,"nodeType":"117","messageId":"118","endLine":116,"endColumn":12},{"ruleId":"115","severity":1,"message":"119","line":116,"column":14,"nodeType":"117","messageId":"118","endLine":116,"endColumn":15},{"ruleId":"115","severity":1,"message":"120","line":116,"column":17,"nodeType":"117","messageId":"118","endLine":116,"endColumn":18},{"ruleId":"115","severity":1,"message":"136","line":116,"column":20,"nodeType":"117","messageId":"118","endLine":116,"endColumn":21},{"ruleId":"115","severity":1,"message":"137","line":116,"column":23,"nodeType":"117","messageId":"118","endLine":116,"endColumn":24},{"ruleId":"115","severity":1,"message":"120","line":129,"column":19,"nodeType":"117","messageId":"118","endLine":129,"endColumn":20},{"ruleId":"128","severity":1,"message":"129","line":153,"column":12,"nodeType":"130","messageId":"131","endLine":153,"endColumn":14},{"ruleId":"138","severity":1,"message":"139","line":321,"column":18,"nodeType":"140","messageId":"141","endLine":321,"endColumn":38,"fix":"142"},{"ruleId":"115","severity":1,"message":"125","line":350,"column":35,"nodeType":"117","messageId":"118","endLine":350,"endColumn":43},{"ruleId":"115","severity":1,"message":"126","line":350,"column":45,"nodeType":"117","messageId":"118","endLine":350,"endColumn":54},{"ruleId":"115","severity":1,"message":"143","line":351,"column":14,"nodeType":"117","messageId":"118","endLine":351,"endColumn":18},{"ruleId":"115","severity":1,"message":"144","line":351,"column":20,"nodeType":"117","messageId":"118","endLine":351,"endColumn":25},{"ruleId":"115","severity":1,"message":"145","line":351,"column":27,"nodeType":"117","messageId":"118","endLine":351,"endColumn":30},{"ruleId":"115","severity":1,"message":"146","line":351,"column":32,"nodeType":"117","messageId":"118","endLine":351,"endColumn":38},{"ruleId":"128","severity":1,"message":"147","line":373,"column":24,"nodeType":"130","messageId":"131","endLine":373,"endColumn":26},{"ruleId":"128","severity":1,"message":"147","line":375,"column":20,"nodeType":"130","messageId":"131","endLine":375,"endColumn":22},{"ruleId":"121","severity":1,"message":"122","line":432,"column":32,"nodeType":"123","messageId":"124","endLine":432,"endColumn":34},{"ruleId":"128","severity":1,"message":"147","line":443,"column":24,"nodeType":"130","messageId":"131","endLine":443,"endColumn":26},{"ruleId":"132","severity":1,"message":"133","line":446,"column":11,"nodeType":"123","messageId":"134","endLine":452,"endColumn":4},{"ruleId":"121","severity":1,"message":"122","line":446,"column":15,"nodeType":"123","messageId":"124","endLine":446,"endColumn":17},{"ruleId":"115","severity":1,"message":"148","line":8,"column":13,"nodeType":"117","messageId":"118","endLine":8,"endColumn":14},{"ruleId":"115","severity":1,"message":"149","line":9,"column":13,"nodeType":"117","messageId":"118","endLine":9,"endColumn":14},{"ruleId":"128","severity":1,"message":"147","line":92,"column":13,"nodeType":"130","messageId":"131","endLine":92,"endColumn":15},{"ruleId":"128","severity":1,"message":"129","line":105,"column":21,"nodeType":"130","messageId":"131","endLine":105,"endColumn":23},{"ruleId":"128","severity":1,"message":"129","line":107,"column":28,"nodeType":"130","messageId":"131","endLine":107,"endColumn":30},{"ruleId":"128","severity":1,"message":"129","line":109,"column":28,"nodeType":"130","messageId":"131","endLine":109,"endColumn":30},{"ruleId":"115","severity":1,"message":"150","line":2,"column":17,"nodeType":"117","messageId":"118","endLine":2,"endColumn":25},{"ruleId":"151","severity":1,"message":"152","line":11,"column":25,"nodeType":"153","endLine":11,"endColumn":100},{"ruleId":"128","severity":1,"message":"129","line":11,"column":26,"nodeType":"130","messageId":"131","endLine":11,"endColumn":28},{"ruleId":"115","severity":1,"message":"154","line":32,"column":9,"nodeType":"117","messageId":"118","endLine":32,"endColumn":16},{"ruleId":"151","severity":1,"message":"152","line":92,"column":11,"nodeType":"153","endLine":92,"endColumn":52},"no-native-reassign",["155"],"no-negated-in-lhs",["156"],"no-unused-vars","'q' is assigned a value but never used.","Identifier","unusedVar","'r' is assigned a value but never used.","'s' is assigned a value but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","'vertDist' is assigned a value but never used.","'horizDist' is assigned a value but never used.","'playerPosition' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'cameFrom', 'cameFrom', 'current'.","unsafeRefs","'Component' is defined but never used.","'x' is assigned a value but never used.","'y' is assigned a value but never used.","no-whitespace-before-property","Unexpected whitespace before property getContext.","MemberExpression","unexpectedWhitespace",{"range":"157","text":"158"},"'left' is assigned a value but never used.","'right' is assigned a value but never used.","'top' is assigned a value but never used.","'bottom' is assigned a value but never used.","Expected '!==' and instead saw '!='.","'j' is assigned a value but never used.","'w' is assigned a value but never used.","'Redirect' is defined but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'statusP' is assigned a value but never used.","no-global-assign","no-unsafe-negation",[12189,12191],"."]