[{"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/index.js":"1","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/App.js":"2","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/reportWebVitals.js":"3","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/PathfindingVisualizer.js":"4","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/Node/Node.js":"5","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/dijkstra/djikstra.js":"6","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS.jsx":"7","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS2.js":"8","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BubbleSort/BubbleSort.js":"9","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/QuickSort/QuickSort.js":"10","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Router.js":"11","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Navbar.js":"12","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/A*Star/A_star.js":"13","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Traveling_Salesperson/TravelingSalesperson.js":"14","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/HomePage/HomePage.js":"15"},{"size":500,"mtime":1607018973582,"results":"16","hashOfConfig":"17"},{"size":396,"mtime":1607891567660,"results":"18","hashOfConfig":"17"},{"size":362,"mtime":1607018973582,"results":"19","hashOfConfig":"17"},{"size":6083,"mtime":1608055752300,"results":"20","hashOfConfig":"17"},{"size":689,"mtime":1607735611637,"results":"21","hashOfConfig":"17"},{"size":2464,"mtime":1607735320937,"results":"22","hashOfConfig":"17"},{"size":17964,"mtime":1607911265487,"results":"23","hashOfConfig":"17"},{"size":18095,"mtime":1607891316216,"results":"24","hashOfConfig":"17"},{"size":2095,"mtime":1608063882592,"results":"25","hashOfConfig":"17"},{"size":4251,"mtime":1608050371701,"results":"26","hashOfConfig":"17"},{"size":1299,"mtime":1608055279666,"results":"27","hashOfConfig":"17"},{"size":1792,"mtime":1608055292893,"results":"28","hashOfConfig":"17"},{"size":8319,"mtime":1607972143422,"results":"29","hashOfConfig":"17"},{"size":5303,"mtime":1607972166050,"results":"30","hashOfConfig":"17"},{"size":1142,"mtime":1608051055058,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},"zofrmq",{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"34"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":1,"source":"50","usedDeprecatedRules":"34"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"53","messages":"54","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"55","messages":"56","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"57","messages":"58","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"59","messages":"60","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"34"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"34"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/index.js",[],["67","68"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/App.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/reportWebVitals.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/PathfindingVisualizer.js",["69","70","71","72","73","74","75","76","77"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/Node/Node.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/dijkstra/djikstra.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS.jsx",["78","79","80","81","82","83","84","85","86","87","88","89"],"import React, {Component} from 'react';\n\nvar DUMMY_OBSTACLES = \n    ['{\"q\":6,\"r\":9,\"s\":-15}', '{\"q\":7,\"r\":8,\"s\":-15}', '{\"q\":7,\"r\":7,\"s\":-14}', '{\"q\":8,\"r\":6,\"s\":-14}', '{\"q\":8,\"r\":5,\"s\":-13}', '{\"q\":9,\"r\":4,\"s\":-13}', '{\"q\":5,\"r\":9,\"s\":-14}',\n    '{\"q\":4,\"r\":9,\"s\":-13}', '{\"q\":3,\"r\":9,\"s\":-12}', '{\"q\":2,\"r\":9,\"s\":-11}', '{\"q\":1,\"r\":9,\"s\":-10}', '{\"q\":0,\"r\":9,\"s\":-9}', '{\"q\":-1,\"r\":9,\"s\":-8}', '{\"q\":-2,\"r\":9,\"s\":-7}', '{\"q\":-3,\"r\":9,\"s\":-6}',\n    '{\"q\":-4,\"r\":9,\"s\":-5}', '{\"q\":-5,\"r\":9,\"s\":-4}', '{\"q\":-6,\"r\":9,\"s\":-3}', '{\"q\":-7,\"r\":9,\"s\":-2}', '{\"q\":-8,\"r\":9,\"s\":-1}', '{\"q\":-9,\"r\":9,\"s\":0}', '{\"q\":-11,\"r\":9,\"s\":2}', '{\"q\":-10,\"r\":9,\"s\":1}',\n    '{\"q\":-12,\"r\":9,\"s\":3}', '{\"q\":-13,\"r\":9,\"s\":4}', '{\"q\":-14,\"r\":9,\"s\":5}', '{\"q\":-15,\"r\":9,\"s\":6}', '{\"q\":-15,\"r\":8,\"s\":7}', '{\"q\":-14,\"r\":7,\"s\":7}', '{\"q\":-14,\"r\":6,\"s\":8}', '{\"q\":-13,\"r\":5,\"s\":8}',\n    '{\"q\":-13,\"r\":4,\"s\":9}', '{\"q\":-12,\"r\":3,\"s\":9}', '{\"q\":-12,\"r\":2,\"s\":10}', '{\"q\":-11,\"r\":1,\"s\":10}', '{\"q\":-11,\"r\":0,\"s\":11}', '{\"q\":-10,\"r\":-1,\"s\":11}', '{\"q\":-10,\"r\":-2,\"s\":12}',\n    '{\"q\":-9,\"r\":-3,\"s\":12}', '{\"q\":-9,\"r\":-4,\"s\":13}', '{\"q\":-8,\"r\":-5,\"s\":13}', '{\"q\":-8,\"r\":-6,\"s\":14}', '{\"q\":-7,\"r\":-7,\"s\":14}', '{\"q\":-7,\"r\":-8,\"s\":15}', '{\"q\":-6,\"r\":-9,\"s\":15}',\n    '{\"q\":-5,\"r\":-9,\"s\":14}', '{\"q\":-4,\"r\":-9,\"s\":13}', '{\"q\":-3,\"r\":-9,\"s\":12}', '{\"q\":-2,\"r\":-9,\"s\":11}', '{\"q\":-1,\"r\":-9,\"s\":10}', '{\"q\":0,\"r\":-9,\"s\":9}', '{\"q\":1,\"r\":-9,\"s\":8}', '{\"q\":2,\"r\":-9,\"s\":7}',\n    '{\"q\":3,\"r\":-9,\"s\":6}', '{\"q\":4,\"r\":-9,\"s\":5}', '{\"q\":5,\"r\":-9,\"s\":4}', '{\"q\":6,\"r\":-9,\"s\":3}', '{\"q\":7,\"r\":-9,\"s\":2}', '{\"q\":8,\"r\":-9,\"s\":1}', '{\"q\":9,\"r\":-9,\"s\":0}', '{\"q\":10,\"r\":-9,\"s\":-1}',\n    '{\"q\":11,\"r\":-9,\"s\":-2}', '{\"q\":12,\"r\":-9,\"s\":-3}', '{\"q\":13,\"r\":-9,\"s\":-4}', '{\"q\":14,\"r\":-9,\"s\":-5}', '{\"q\":15,\"r\":-9,\"s\":-6}', '{\"q\":15,\"r\":-8,\"s\":-7}', '{\"q\":14,\"r\":-7,\"s\":-7}',\n    '{\"q\":14,\"r\":-6,\"s\":-8}', '{\"q\":13,\"r\":-5,\"s\":-8}', '{\"q\":13,\"r\":-4,\"s\":-9}', '{\"q\":12,\"r\":-3,\"s\":-9}', '{\"q\":12,\"r\":-2,\"s\":-10}', '{\"q\":11,\"r\":-1,\"s\":-10}', '{\"q\":11,\"r\":0,\"s\":-11}',\n    '{\"q\":10,\"r\":1,\"s\":-11}', '{\"q\":10,\"r\":2,\"s\":-12}', '{\"q\":9,\"r\":3,\"s\":-12}', '{\"q\":-2, \"r\":-8, \"s\":10}', '{\"q\": -3, \"r\": -7, \"s\": 10}', '{\"q\": -4, \"r\": -6, \"s\": 10}', '{\"q\": -5, \"r\": -5, \"s\": 10}',\n    '{\"q\": -6, \"r\": -4, \"s\": 10}', '{\"q\": -7, \"r\": -4, \"s\": 11}', '{\"q\": 4, \"r\": -7, \"s\": 3}', '{\"q\": 3, \"r\": -6, \"s\": 3}', '{\"q\": 2, \"r\": -5, \"s\": 3}',\n    '{\"q\": 1, \"r\": -4, \"s\": 3}',\n    '{\"q\": 2, \"r\": -4, \"s\": 2}',\n    '{\"q\": 3, \"r\": -4, \"s\": 1}',\n    '{\"q\": 4, \"r\": -4, \"s\": 0}',\n    '{\"q\": 9, \"r\": -3, \"s\": -6}',\n    '{\"q\": 10, \"r\": -3, \"s\": -7}',\n    '{\"q\": 8, \"r\": -2, \"s\": -6}',\n    '{\"q\": 7, \"r\": -2, \"s\": -5}',\n    '{\"q\": 4, \"r\": -2, \"s\": -2}',\n    '{\"q\": 4, \"r\": -1, \"s\": -3}',\n    '{\"q\": 4, \"r\": 0, \"s\": -4}',\n    '{\"q\": 4, \"r\": 1, \"s\": -5}',\n    '{\"q\": 3, \"r\": 2, \"s\": -5}',\n    '{\"q\": 2, \"r\": 3, \"s\": -5}',\n    '{\"q\": 1, \"r\": 4, \"s\": -5}',\n    '{\"q\": -0, \"r\": 5, \"s\": -5}',\n    '{\"q\": -1, \"r\": 6, \"s\": -5}',\n    '{\"q\": -2, \"r\": 7, \"s\": -5}',\n    '{\"q\": 4, \"r\": 5, \"s\": -9}',\n    '{\"q\": 4, \"r\": 6, \"s\": -10}',\n    '{\"q\": 5, \"r\": 6, \"s\": -11}',\n    '{\"q\": 5, \"r\": 7, \"s\": -12}',\n    '{\"q\": -5, \"r\": 7, \"s\": -2}',\n    '{\"q\": -5, \"r\": 8, \"s\": -3}',\n    '{\"q\": -5, \"r\": 6, \"s\": -1}',\n    '{\"q\": -5, \"r\": 5, \"s\": 0}',\n    '{\"q\": -4, \"r\": 4, \"s\": -0}',\n    '{\"q\": -3, \"r\": 3, \"s\": -0}',\n    '{\"q\": -5, \"r\": 3, \"s\": 2}',\n    '{\"q\": -6, \"r\": 4, \"s\": 2}',\n    '{\"q\": -4, \"r\": 2, \"s\": 2}',\n    '{\"q\": -4, \"r\": 1, \"s\": 3}',\n    '{\"q\": -7, \"r\": 4, \"s\": 3}',\n    '{\"q\": -8, \"r\": 4, \"s\": 4}',\n    '{\"q\": -9, \"r\": 4, \"s\": 5}',\n    '{\"q\": -10, \"r\": 4, \"s\": 6}',\n    '{\"q\": -11, \"r\": 4, \"s\": 7}',\n    '{\"q\": -12, \"r\": 4, \"s\": 8}',\n    '{\"q\": -6, \"r\": 1, \"s\": 5}',\n    '{\"q\": -6, \"r\": 0, \"s\": 6}',\n    '{\"q\": -6, \"r\": -1, \"s\": 7}',\n    '{\"q\": -6, \"r\": -2, \"s\": 8}',\n    '{\"q\": -2, \"r\": -1, \"s\": 3}',\n    '{\"q\": -2, \"r\": -2, \"s\": 4}']\n\n\n\n\nexport default class BreadthFirstSearch extends Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.handleClick = this.handleClick.bind(this);\n    this.handleExpandClick = this.handleExpandClick.bind(this);\n\n    this.state = {\n      hexSize: 20,\n      //position of the very middle hexagon (changes the numbers seen in hexagons)\n      //decreasing y moves hexagon(0,0,0) upwards, increasing x moves hexagon(0,0,0) to the right\n      hexOrigin: { x: 400, y: 300 },\n      currentHex: {q: 0, r: 0, s: 0, x: 0, y: 0},\n      playerPosition: {q: 0, r: 0, s: 0, x: 400, y: 300},\n      obstacles: DUMMY_OBSTACLES,\n      frontier: [],\n      //storing hexagons starting from playerPosition\n      cameFrom: {}\n    }\n  }\n  componentWillMount(){\n    let hexParametres = this.getHexParametres();\n    this.setState({\n      canvasSize: { canvasWidth: 800, canvasHeight: 600 },\n      hexParametres: hexParametres\n    })\n  }\n\n  componentDidMount(){\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    this.canvasHex.width = canvasWidth;\n    this.canvasHex.height = canvasHeight;\n    this.canvasInteraction.width = canvasWidth;\n    this.canvasInteraction.height = canvasHeight;\n    this.canvasView.width = canvasWidth;\n    this.canvasView.height = canvasHeight;\n    this.getCanvasPosition(this.canvasInteraction);\n    this.drawHex(this.canvasInteraction, this.Point(this.state.playerPosition.x, this.state.playerPosition.y), 1, \"grey\", \"red\", 0.2);\n    this.drawHexes();\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if(nextState.currentHex !== this.state.currentHex) {\n      const { q, r, s, x, y } = nextState.currentHex;\n      const { canvasWidth, canvasHeight } = this.state.canvasSize;\n      const ctx = this.canvasInteraction.getContext(\"2d\");\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n      let currentDistanceLine = nextState.currentDistanceLine;\n\n      for (let i = 0; i <= currentDistanceLine.length - 2; i++) {\n        if(i === 0) {\n          this.drawHex(this.canvasInteraction, this.Point(currentDistanceLine[i].x, currentDistanceLine[i].y), 1, \"black\", \"red\");\n        }else {\n          this.drawHex(this.canvasInteraction, this.Point(currentDistanceLine[i].x, currentDistanceLine[i].y), 1, \"black\", \"grey\");\n        }\n\n      }\n      nextState.obstacles.map((l)=>{\n        const { q, r, s } = JSON.parse(l);\n        const { x, y } = this.hexToPixel(this.Hex(q, r, s))\n        this.drawHex(this.canvasInteraction, this.Point(x, y), 1, \"black\", \"black\");\n\n      })\n      this.drawHex(this.canvasInteraction, this.Point(x, y), 1, \"black\", \"grey\");\n      return true;\n    }\n    if(nextState.cameFrom !== this.state.cameFrom) {\n      const { canvasWidth, canvasHeight } = this.state.canvasSize;\n      const ctx = this.canvasView.getContext(\"2d\");\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n      for(let l in nextState.cameFrom) {\n        const { q, r, s } = JSON.parse(l);\n        const { x, y } = this.hexToPixel(this.Hex(q, r));\n        this.drawHex(this.canvasView, this.Point(x, y), 1, \"black\", \"green\", 0.1);\n      }\n      return true;\n    }\n\n    return false;\n  }\n\n\n  drawHexes() {\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n    //calculate how many columns are on the left side\n    //hexOrigin is distance from coorindate x = 0 to hex0(middle hexagon)\n    const hexOrigin = this.state.hexOrigin;\n    //dividing the distance from the left side of border(x=0) by\n    //the width of a hexagon to calculate how many hexagons fit on left\n    let qLeftSide = Math.round(hexOrigin.x/horizDist);\n    //calculate how many hexagons will fit on the right\n    let qRightSide = Math.round((canvasWidth - hexOrigin.x)/horizDist);\n    let rTopSide = Math.round(hexOrigin.y/vertDist);\n    let rBottomSide = Math.round((canvasHeight - hexOrigin.y)/vertDist);\n    var p = 0;\n    //screenshot 1 - populates hexigons vertically (populates POSITIVE rows)\n    for(let r = 0; r <= rBottomSide; r++) {\n      if(r%2 === 0 && r !== 0) {\n        p++;\n      }\n      //populates hexigons horizontally in upper half (populates POSITIVE columns)\n      for(let q = -qLeftSide; q <= qRightSide; q++) {\n          const { x, y } = this.hexToPixel(this.Hex(q-p, r));\n          if((x > hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n            this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n            //passing in canvas and position of each hex(row, column)\n\n          }\n      }\n    }\n    var n = 0;\n    //screenshot 1 - populates hexigons vertically (populates NEGATIVE rows)\n    for(let r = -1; r >= -rTopSide; r--) {\n      if(r%2 !== 0) {\n        n++;\n      }\n      //populates hexigons horizontally in lower half (populates NEGATIVE columns)\n      for(let q = -qLeftSide; q <= qRightSide; q++) {\n          //adding integers to hexToPixel arguments shifts hexagons right\n          const { x, y } = this.hexToPixel(this.Hex(q+n, r));\n          if((x > hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n            this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n\n          }\n      }\n    }\n  }\n\n  //builds the individual hex shape\n  drawHex(canvasID, center, lineWidth, lineColor, fillColor) {\n    for(let i = 0; i <=5; i++) {\n      let start = this.getHexCornerCoord(center, i);\n      let end = this.getHexCornerCoord(center, i + 1);\n\n      this.fillHex(canvasID, center, fillColor);\n      this.drawLine(canvasID, start, end, lineWidth, lineColor);\n\n    }\n  }\n\n  //get the coordinates of the corner to draw the hex\n    getHexCornerCoord(center, i) {\n      var angle_deg = 60 * i + 30;\n      var angle_rad = Math.PI / 180 * angle_deg;\n      let x = center.x + this.state.hexSize * Math.cos(angle_rad);\n      let y = center.y + this.state.hexSize * Math.sin(angle_rad);\n      return this.Point(x, y);\n    }\n\n    Hex(q, r, s) {\n      return {q: q, r: r, s: s}\n    }\n\n    Point(x, y) {\n      return {x: x, y: y}\n    }\n\n//draws the line that shapes the hex\n  drawLine(canvasID, start, end, lineWidth, lineColor) {\n    const ctx = canvasID.getContext(\"2d\");\n    ctx.beginPath();\n    ctx.moveTo(start.x, start.y);\n    ctx.strokeStyle = lineColor;\n    ctx.lineWidth = lineWidth;\n    ctx.lineTo(end.x, end.y);\n    ctx.stroke();\n    ctx.closePath();\n  }\n\n  fillHex(canvasID, center, fillColor) {\n    let c0 = this.getHexCornerCoord(center, 0);\n    let c1 = this.getHexCornerCoord(center, 1);\n    let c2 = this.getHexCornerCoord(center, 2);\n    let c3 = this.getHexCornerCoord(center, 3);\n    let c4 = this.getHexCornerCoord(center, 4);\n    let c5 = this.getHexCornerCoord(center, 5);\n    const ctx = canvasID.getContext(\"2d\");\n    ctx.beginPath();\n    ctx.fillStyle = fillColor;\n    ctx.globalAlpha = 0.1;\n    ctx.moveTo(c0.x, c0.y);\n    ctx.lineTo(c1.x, c1.y);\n    ctx.lineTo(c2.x, c2.y);\n    ctx.lineTo(c3.x, c3.y);\n    ctx.lineTo(c4.x, c4.y);\n    ctx.lineTo(c5.x, c5.y);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n//prints the coordinates inside of the hexagons\n  drawHexCoordinates(canvasID, center, h) {\n    const ctx = canvasID.getContext(\"2d\");\n    ctx.fillText(h.q, center.x+6, center.y);\n    ctx.fillText(h.r, center.x-3, center.y+15);\n    ctx.fillText(h.s, center.x-12, center.y);\n  }\n\n\n\n  getHexParametres() {\n    let hexHeight = this.state.hexSize * 2;\n    let hexWidth = Math.sqrt(3)/2 * hexHeight;\n    //vertical distance between hexigons in each row\n    let vertDist = hexHeight * 3/4;\n    let horizDist = hexWidth;\n    return { hexWidth, hexHeight, vertDist, horizDist }\n  }\n\n  hexToPixel(h) {\n    //can change where the bundle of hexes originates on the whole grid\n    let hexOrigin = this.state.hexOrigin;\n    let x = this.state.hexSize * Math.sqrt(3) * (h.q + h.r/2) + hexOrigin.x;\n    let y = this.state.hexSize * 3/2 * h.r + hexOrigin.y;\n    return this.Point(x, y)\n  }\n\n  pixelToHex(p) {\n    let size = this.state.hexSize;\n    let origin = this.state.hexOrigin;\n    let q = ((p.x - origin.x) * Math.sqrt(3)/3 - (p.y - origin.y) / 3) / size\n    let r = (p.y - origin.y) * 2/3 / size\n    return this.Hex(q, r, -q - r);\n  }\n\n  getDistanceLine(hexA, hexB) {\n    let dist = this.cubeDistance(hexA, hexB);\n    var arr = [];\n    for(let i = 0; i <= dist; i++) {\n     let center = this.hexToPixel(this.cubeRound(this.cubeLinearInt(hexA, hexB, 1.0 / dist * i)));\n     arr = [].concat(arr, center);\n    }\n    this.setState({\n      currentDistanceLine: arr\n    })\n  }\n\n\n\n  cubeDirection(direction) {\n    const cubeDirections = [this.Hex(1, 0, -1), this.Hex(1, -1, 0), this.Hex(0, -1, 1),\n    this.Hex(-1, 0, 1), this.Hex(-1, 1, 0), this.Hex(0, 1, -1)];\n    return cubeDirections[direction];\n  }\n\n  cubeLinearInt(hexA, hexB, t) {\n    return this.Hex(this.linearInt(hexA.q, hexB.q, t), this.linearInt(hexA.r, hexB.r, t),\n    this.linearInt(hexA.s, hexB.s, t));\n  }\n\n  linearInt(a, b, t) {\n    return (a + (b - a) * t)\n  }\n\n  cubeAdd(a, b) {\n    return this.Hex(a.q + b.q, a.r + b.r, a.s + b.s);\n  }\n\n  cubeSubstract(hexA, hexB) {\n    return this.Hex(hexA.q - hexB.q, hexA.r - hexB.r, hexA.s - hexB.s);\n  }\n\n  getCubeNeighbor(h, direction) {\n    return this.cubeAdd(h, this.cubeDirection(direction));\n  }\n\n  getNeighbors(h) {\n    var arr = [];\n    for(let i = 0; i <=5; i++) {\n      const { q, r, s } = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n      arr.push(this.Hex(q, r, s));\n    }\n    return arr;\n  }\n\n\n\n  cubeRound(cube) {\n    var rx = Math.round(cube.q)\n    var ry = Math.round(cube.r)\n    var rz = Math.round(cube.s)\n    var x_diff = Math.abs(rx - cube.q)\n    var y_diff = Math.abs(ry - cube.r)\n    var z_diff = Math.abs(rz - cube.s)\n    if(x_diff > y_diff && x_diff > z_diff) {\n      rx = -ry-rz\n    }\n    else if(y_diff > z_diff) {\n      ry = -rx-rz\n    }\n    else{\n      rz = -rx-ry\n    }\n    return this.Hex(rx, ry, rz)\n  }\n\n\n\n  cubeDistance(hexA, hexB) {\n    const { q, r, s } = this.cubeSubstract(hexA, hexB);\n    return (Math.abs(q) + Math.abs(r) + Math.abs(s)) / 2;\n  }\n\n\n  drawNeighbors(h) {\n    for(let i = 0; i <= 5; i++) {\n      const { q, r, s } = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n      const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n      this.drawHex(this.canvasInteraction, this.Point(x, y), \"red\", 2);\n    }\n  }\n\n\n    getCanvasPosition(canvasID) {\n      let rect = canvasID.getBoundingClientRect();\n      this.setState({\n         canvasPosition: { left:rect.left, right: rect.right, top: rect.top, bottom: rect.bottom }\n      })\n    }\n\n  handleMouseMove(e) {\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n    //const { left, right, top, bottom } = this.state.canvasPosition;\n    //changing the number at the end affects result exponentially\n    var canvasPos = document.getElementById(\"canv3\");\n    let rect = canvasPos.getBoundingClientRect();\n    let offsetX = e.pageX - rect.left;\n    let offsetY = (e.pageY - (window.pageYOffset + rect.top));\n\n\n\n\n\n\n    const { q, r, s } = this.cubeRound(this.pixelToHex(this.Point(offsetX, offsetY)));\n    const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n\n   let playerPosition = this.state.playerPosition;\n\n\n    this.getDistanceLine(this.Hex(0,0,0), this.Hex(q,r,s));\n\n    if((x > hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n      this.setState({\n        currentHex: {q, r, s, x, y}\n      })\n    }\n\n  }\n\n  handleClick() {\n    this.addObstacles();\n  }\n\n  addObstacles() {\n    const { q, r, s } = this.state.currentHex;\n    let obstacles = this.state.obstacles;\n    if(!obstacles.includes(JSON.stringify(this.Hex(q, r, s)))) {\n      obstacles = [].concat(obstacles, JSON.stringify(this.Hex(q, r, s)))\n    } else {\n      obstacles.map((l,i) => {\n        if(l === JSON.stringify(this.Hex(q, r, s))) {\n          obstacles = obstacles.slice(0, i).concat(obstacles.slice(i+1));\n        }\n      })\n    }\n    console.log({\"q\":q, \"r\":r, \"s\":s})\n    this.setState({\n      obstacles: obstacles\n    })\n  }\n\n  handleExpandClick() {\n    var frontier = this.state.frontier;\n    var cameFrom = this.state.cameFrom;\n    if(frontier == 0) {\n      frontier.push(this.Hex(0,0,0));\n      cameFrom[JSON.stringify(this.Hex(0,0,0))] = JSON.stringify(null);\n    }\n    let n = 0;\n    while(n < 1) {\n      var current = frontier.shift();\n      let arr = this.getNeighbors(current);\n      arr.map((l) => {\n        if(!cameFrom.hasOwnProperty(JSON.stringify(l)) && !this.state.obstacles.includes(JSON.stringify(l))) {\n          frontier.push(l);\n          cameFrom[JSON.stringify(l)] = JSON.stringify(current);\n        }\n      })\n      n++\n    }\n    cameFrom = Object.assign({}, cameFrom);\n    this.setState({\n      cameFrom: cameFrom\n    })\n  }\n\n  resetSketch() {\n  window.location.reload();\n  }\n\n\nrender() {\n    return (\n      <section id=\"BFS\">\n        <div className=\"description25\">\n        <b id=\"bold\">How to use:</b> Hit expand to see Breadth First Search carried out starting\n          from the middle node.\n        </div>\n\n          <button\n              className=\"reset1\"\n              onClick={ this.resetSketch }\n              style= {{ textAlign: \"center\" }}\n            >\n              Reset\n            </button>\n\n            <button\n              className=\"expandButton1\"\n              color=\"blue\"\n              style={{textAlign: \"center\"}}\n              onClick={this.handleExpandClick}>\n              Expand\n            </button>\n\n            <br></br>\n        <canvas id=\"canv4\" ref={canvasHex => this.canvasHex = canvasHex }> </canvas>\n        <canvas id=\"canv3\" ref={canvasCoordinates => this.canvasCoordinates = canvasCoordinates }> </canvas>\n        <canvas id=\"canv2\" ref={canvasView => this.canvasView = canvasView }> </canvas>\n        <canvas id=\"canv1\" ref={canvasInteraction => this.canvasInteraction = canvasInteraction} onMouseMove = {this.handleMouseMove} onClick = {this.handleClick}> </canvas>\n    </section>\n    )\n  }\n}","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS2.js",["90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110"],"import React, {Component} from 'react';\n\nvar DUMMY_OBSTACLES = ['{\"q\":4,\"r\":-2,\"s\":-2}', \n'{\"q\":4,\"r\":-1,\"s\":-3}', '{\"q\":4,\"r\":0,\"s\":-4}', \n'{\"q\":4,\"r\":1,\"s\":-5}', '{\"q\":3,\"r\":2,\"s\":-5}', \n'{\"q\":2,\"r\":3,\"s\":-5}', '{\"q\":1,\"r\":4,\"s\":-5}', \n'{\"q\":0,\"r\":5,\"s\":-5}', '{\"q\":-1,\"r\":6,\"s\":-5}', \n'{\"q\":-2,\"r\":7,\"s\":-5}', '{\"q\":4,\"r\":-4,\"s\":0}', \n'{\"q\":3,\"r\":-4,\"s\":1}', '{\"q\":2,\"r\":-4,\"s\":2}', \n'{\"q\":1,\"r\":-4,\"s\":3}', '{\"q\":2,\"r\":-5,\"s\":3}', \n'{\"q\":3,\"r\":-6,\"s\":3}', '{\"q\":4,\"r\":-7,\"s\":3}', \n'{\"q\":5,\"r\":-9,\"s\":4}', '{\"q\":6,\"r\":-9,\"s\":3}', \n'{\"q\":7,\"r\":-9,\"s\":2}', '{\"q\":8,\"r\":-9,\"s\":1}', \n'{\"q\":9,\"r\":-9,\"s\":0}', '{\"q\":10,\"r\":-9,\"s\":-1}', \n'{\"q\":11,\"r\":-9,\"s\":-2}', '{\"q\":12,\"r\":-9,\"s\":-3}', \n'{\"q\":13,\"r\":-9,\"s\":-4}', '{\"q\":14,\"r\":-9,\"s\":-5}', \n'{\"q\":15,\"r\":-9,\"s\":-6}', '{\"q\":15,\"r\":-8,\"s\":-7}', \n'{\"q\":14,\"r\":-7,\"s\":-7}', '{\"q\":14,\"r\":-6,\"s\":-8}', \n'{\"q\":13,\"r\":-5,\"s\":-8}', '{\"q\":13,\"r\":-4,\"s\":-9}', \n'{\"q\":12,\"r\":-3,\"s\":-9}', '{\"q\":12,\"r\":-2,\"s\":-10}', \n'{\"q\":11,\"r\":-1,\"s\":-10}', '{\"q\":11,\"r\":0,\"s\":-11}', \n'{\"q\":10,\"r\":1,\"s\":-11}', '{\"q\":10,\"r\":2,\"s\":-12}', \n'{\"q\":9,\"r\":3,\"s\":-12}', '{\"q\":9,\"r\":4,\"s\":-13}', \n'{\"q\":8,\"r\":5,\"s\":-13}', '{\"q\":8,\"r\":6,\"s\":-14}', \n'{\"q\":7,\"r\":7,\"s\":-14}', '{\"q\":7,\"r\":8,\"s\":-15}', \n'{\"q\":6,\"r\":9,\"s\":-15}', '{\"q\":5,\"r\":9,\"s\":-14}', \n'{\"q\":4,\"r\":9,\"s\":-13}', '{\"q\":3,\"r\":9,\"s\":-12}', \n'{\"q\":2,\"r\":9,\"s\":-11}', '{\"q\":1,\"r\":9,\"s\":-10}', \n'{\"q\":0,\"r\":9,\"s\":-9}', '{\"q\":-1,\"r\":9,\"s\":-8}', \n'{\"q\":-2,\"r\":9,\"s\":-7}', '{\"q\":-3,\"r\":9,\"s\":-6}', \n'{\"q\":-4,\"r\":9,\"s\":-5}', '{\"q\":-5,\"r\":9,\"s\":-4}', \n'{\"q\":-5,\"r\":8,\"s\":-3}', '{\"q\":-5,\"r\":7,\"s\":-2}', \n'{\"q\":-5,\"r\":6,\"s\":-1}', '{\"q\":-5,\"r\":5,\"s\":0}', \n'{\"q\":-4,\"r\":4,\"s\":0}', '{\"q\":-3,\"r\":3,\"s\":0}', \n'{\"q\":-2,\"r\":-1,\"s\":3}', '{\"q\":-2,\"r\":-2,\"s\":4}', \n'{\"q\":-4,\"r\":1,\"s\":3}', '{\"q\":-4,\"r\":2,\"s\":2}', \n'{\"q\":-5,\"r\":3,\"s\":2}', '{\"q\":-7,\"r\":4,\"s\":3}', \n'{\"q\":-6,\"r\":4,\"s\":2}', '{\"q\":-8,\"r\":4,\"s\":4}', \n'{\"q\":-9,\"r\":4,\"s\":5}', '{\"q\":-10,\"r\":4,\"s\":6}', \n'{\"q\":-11,\"r\":4,\"s\":7}', '{\"q\":-12,\"r\":4,\"s\":8}', \n'{\"q\":-12,\"r\":2,\"s\":10}', '{\"q\":-12,\"r\":3,\"s\":9}', \n'{\"q\":-13,\"r\":4,\"s\":9}', '{\"q\":-13,\"r\":5,\"s\":8}', \n'{\"q\":-14,\"r\":6,\"s\":8}', '{\"q\":-14,\"r\":7,\"s\":7}', \n'{\"q\":-15,\"r\":8,\"s\":7}', '{\"q\":-15,\"r\":9,\"s\":6}', \n'{\"q\":-14,\"r\":9,\"s\":5}', '{\"q\":-13,\"r\":9,\"s\":4}', \n'{\"q\":-12,\"r\":9,\"s\":3}', '{\"q\":-11,\"r\":9,\"s\":2}', \n'{\"q\":-10,\"r\":9,\"s\":1}', '{\"q\":-9,\"r\":9,\"s\":0}', \n'{\"q\":-8,\"r\":9,\"s\":-1}', '{\"q\":-7,\"r\":9,\"s\":-2}', \n'{\"q\":-6,\"r\":9,\"s\":-3}', '{\"q\":-11,\"r\":1,\"s\":10}', \n'{\"q\":-11,\"r\":0,\"s\":11}', '{\"q\":-10,\"r\":-1,\"s\":11}', \n'{\"q\":-10,\"r\":-2,\"s\":12}', '{\"q\":-9,\"r\":-3,\"s\":12}', \n'{\"q\":-9,\"r\":-4,\"s\":13}', '{\"q\":-8,\"r\":-5,\"s\":13}', \n'{\"q\":-8,\"r\":-6,\"s\":14}', '{\"q\":-7,\"r\":-7,\"s\":14}', \n'{\"q\":-7,\"r\":-8,\"s\":15}', '{\"q\":-6,\"r\":-9,\"s\":15}', \n'{\"q\":-5,\"r\":-9,\"s\":14}', '{\"q\":-4,\"r\":-9,\"s\":13}', \n'{\"q\":-3,\"r\":-9,\"s\":12}', '{\"q\":-2,\"r\":-9,\"s\":11}', \n'{\"q\":-1,\"r\":-9,\"s\":10}', '{\"q\":0,\"r\":-9,\"s\":9}', \n'{\"q\":1,\"r\":-9,\"s\":8}', '{\"q\":2,\"r\":-9,\"s\":7}', \n'{\"q\":3,\"r\":-9,\"s\":6}', '{\"q\":4,\"r\":-9,\"s\":5}', \n'{\"q\":-2,\"r\":-8,\"s\":10}', '{\"q\":-3,\"r\":-7,\"s\":10}', \n'{\"q\":-4,\"r\":-6,\"s\":10}', '{\"q\":-5,\"r\":-5,\"s\":10}', \n'{\"q\":-6,\"r\":-4,\"s\":10}', '{\"q\":-7,\"r\":-4,\"s\":11}', \n'{\"q\":-6,\"r\":-2,\"s\":8}', '{\"q\":-6,\"r\":-1,\"s\":7}', \n'{\"q\":-6,\"r\":0,\"s\":6}', '{\"q\":-6,\"r\":1,\"s\":5}', \n'{\"q\":7,\"r\":-2,\"s\":-5}', '{\"q\":8,\"r\":-2,\"s\":-6}', \n'{\"q\":9,\"r\":-3,\"s\":-6}', '{\"q\":10,\"r\":-3,\"s\":-7}', \n'{\"q\":4,\"r\":5,\"s\":-9}', '{\"q\":4,\"r\":6,\"s\":-10}', \n'{\"q\":5,\"r\":6,\"s\":-11}', '{\"q\":5,\"r\":7,\"s\":-12}']\n\n\nexport default class BFSExtra extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.handleClick = this.handleClick.bind(this);\n    //possibly but this.breadthFirstSearch = this.breadthfirstsearch.bind(this)\n\n\n    this.state = {\n      hexSize: 20,\n      //position of the very middle hexagon (changes the numbers seen in hexagons)\n      //decreasing y moves hexagon(0,0,0) upwards, increasing x moves hexagon(0,0,0) to the right\n      hexOrigin: { x: 400, y: 300 },\n      currentHex: {q: 0, r: 0, s: 0, x: 0, y: 0},\n      playerPosition: { q: 0, r: 0, s: 0 },\n      obstacles: DUMMY_OBSTACLES,\n      cameFrom: {},\n      hexPathMap: [],\n      path: []\n    }\n  }\n  componentWillMount(){\n    let hexParametres =  this.getHexParametres();\n    this.setState({\n      canvasSize: { canvasWidth: 800, canvasHeight: 600 },\n      hexParametres: hexParametres\n    })\n  }\n\n  componentDidMount(){\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    this.canvasHex.width = canvasWidth;\n    this.canvasHex.height = canvasHeight;\n    this.canvasInteraction.width = canvasWidth;\n    this.canvasInteraction.height = canvasHeight;\n    this.canvasView.width = canvasWidth;\n    this.canvasView.height = canvasHeight;\n    this.getCanvasPosition(this.canvasInteraction);\n    this.drawHex(this.canvasInteraction, this.Point(this.state.playerPosition.x, this.state.playerPosition.y), 1, \"grey\", \"red\", 0.2);\n    this.drawHexes();\n    this.drawObstacles();\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if(nextState.currentHex !== this.state.currentHex) {\n  const { q, r, s, x, y } = nextState.currentHex;\n  const { canvasWidth, canvasHeight } = this.state.canvasSize;\n  const ctx = this.canvasInteraction.getContext(\"2d\");\n  ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n  /*this.drawNeighbors(this.Hex(q, r, s));*/\n  this.drawPath();\n  return true;\n}\n  if(nextState.cameFrom !== this.state.cameFrom) {\n  const { canvasWidth, canvasHeight } = this.state.canvasSize;\n  const ctx = this.canvasView.getContext(\"2d\");\n  ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n  for (let l in nextState.cameFrom) {\n    const { q, r, s } = JSON.parse(l);\n    const { x, y } = this.hexToPixel(this.Hex(q, r));\n    this.drawHex(this.canvasView, this.Point(x, y), 1, \"black\", \"green\", 0.1);\n    var from = JSON.parse(nextState.cameFrom[l]);\n    var fromCoord = this.hexToPixel(this.Hex(from.q, from.r));\n    this.drawArrow(fromCoord.x, fromCoord.y, x, y);\n  }\n  return true;\n  }\n  return false;\n  }\n\n\n  drawHexes() {\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n  const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n  const hexOrigin = this.state.hexOrigin;\n  let qLeftSide = Math.round(hexOrigin.x/horizDist);\n  let qRightSide = Math.round((canvasWidth - hexOrigin.x)/horizDist);\n  let rTopSide = Math.round(hexOrigin.y/vertDist);\n  let rBottomSide = Math.round((canvasHeight - hexOrigin.y)/vertDist);\n  var hexPathMap = [];\n  var p = 0;\n  for (let r = 0; r <= rBottomSide; r++) {\n    if(r%2 == 0 && r !==0) {\n      p++;\n    }\n    for (let q = -qLeftSide; q <= qRightSide; q++) {\n        const { x, y } = this.hexToPixel(this.Hex(q-p, r));\n        if ((x >hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n          this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n          /*this.drawHexCoordinates(this.canvasHex, this.Point(x,y), this.Hex(q-p, r, -(q - p) - r));*/\n          var bottomH = JSON.stringify(this.Hex(q-p, r, -(q - p) - r));\n          if(!this.state.obstacles.includes(bottomH)) {\n            hexPathMap.push(bottomH);\n          }\n        }\n    }\n  }\nvar n = 0;\n  for (let r = -1; r >= -rTopSide; r--) {\n    if(r%2 !== 0) {\n      n++;\n    }\n    for (let q = -qLeftSide; q <= qRightSide; q++) {\n        const { x, y } = this.hexToPixel(this.Hex(q+n, r));\n          if ((x >hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n        this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n        /*this.drawHexCoordinates(this.canvasHex, this.Point(x,y), this.Hex(q+n, r, - (q + n) - r));*/\n        var topH = JSON.stringify(this.Hex(q+n, r, - (q + n) - r));\n        if(!this.state.obstacles.includes(topH)) {\n          hexPathMap.push(topH);\n        }\n      }\n    }\n  }\n  hexPathMap = [].concat(hexPathMap);\n  this.setState(\n    {hexPathMap: hexPathMap},\n    this.breadthFirstSearchCallback = () => this.breadthFirstSearch(this.state.playerPosition)\n  )\n  }\n\n  //builds the individual hex shape\n  drawHex(canvasID, center, lineWidth, lineColor, fillColor) {\n  for (let i = 0; i <= 5; i++) {\n    let start = this.getHexCornerCoord(center, i);\n    let end = this.getHexCornerCoord(center, i + 1);\n    this.fillHex(canvasID, center, fillColor);\n    this.drawLine(canvasID, start, end, lineWidth, lineColor);\n  }\n}\n\n  //get the coordinates of the corner to draw the hex\n  getHexCornerCoord(center, i) {\n   let angle_deg = 60 * i   + 30;\n   let angle_rad = Math.PI / 180 * angle_deg;\n   let x = center.x + this.state.hexSize * Math.cos(angle_rad);\n  let y = center.y + this.state.hexSize * Math.sin(angle_rad);\n  return this.Point(x, y);\n }\n\n getHexParametres() {\n  let hexHeight = this.state.hexSize * 2;\n  let hexWidth = Math.sqrt(3)/2 * hexHeight;\n  let vertDist = hexHeight * 3/4;\n  let horizDist = hexWidth;\n  return { hexWidth, hexHeight, vertDist, horizDist }\n}\n\ngetCanvasPosition(canvasID) {\n  let rect = canvasID.getBoundingClientRect();\n  this.setState({\n    canvasPosition: { left:rect.left, right: rect.right, top: rect.top, bottom: rect.bottom }\n  })\n}\n   hexToPixel(h) {\n     let hexOrigin = this.state.hexOrigin;\n     let x = this.state.hexSize * Math.sqrt(3) * (h.q + h.r/2) + hexOrigin.x;\n     let y = this.state.hexSize * 3/2 * h.r + hexOrigin.y;\n     return this.Point(x, y)\n   }\n   pixelToHex(p) {\n     let size = this.state.hexSize;\n     let origin = this.state.hexOrigin;\n     let q = ((p.x - origin.x) * Math.sqrt(3)/3 - (p.y - origin.y) / 3) / size\n     let r = (p.y - origin.y) * 2/3 / size\n     return this.Hex(q, r, - q - r);\n   }\ncubeDirection(direction) {\n  const cubeDirections = [this.Hex(1, 0, -1), this.Hex(1, -1, 0), this.Hex(0, -1, 1),\n                          this.Hex(-1, 0, 1), this.Hex(-1, 1, 0), this.Hex(0, 1, -1)];\nreturn cubeDirections[direction];\n}\ncubeAdd(a, b) {\n  return this.Hex(a.q + b.q, a.r + b.r, a.s + b.s);\n}\ncubeSubstract(hexA, hexB) {\n  return this.Hex(hexA.q - hexB.q, hexA.r - hexB.r, hexA.s - hexB.s);\n}\ngetCubeNeighbor(h, direction) {\n  return this.cubeAdd(h, this.cubeDirection(direction));\n}\ngetNeighbors(h) {\n  var arr = [];\n  for (let i = 0; i <= 5; i++) {\n    const { q, r, s } = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n    arr.push(this.Hex(q, r, s));\n  }\n  return arr;\n}\n   cubeRound(cube) {\n     var rx = Math.round(cube.q)\n     var ry = Math.round(cube.r)\n     var rz = Math.round(cube.s)\n     var x_diff = Math.abs(rx - cube.q)\n     var y_diff = Math.abs(ry - cube.r)\n     var z_diff = Math.abs(rz - cube.s)\n     if (x_diff > y_diff && x_diff > z_diff) {\n       rx = -ry-rz;\n     } else if (y_diff > z_diff) {\n          ry = -rx-rz\n     } else {\n          rz = -rx-ry\n     }\n     return this.Hex(rx, ry, rz)\n   }\ngetDistanceLine(hexA, hexB) {\n  let dist = this.cubeDistance(hexA, hexB);\n  var arr = [];\n  for (let i = 0; i <= dist; i++) {\n  let center = this.hexToPixel(this.cubeRound(this.cubeLinearInt(hexA, hexB, 1.0 / dist * i)));\n  arr = [].concat(arr, center);\n  }\n  this.setState({\n    currentDistanceLine: arr\n  })\n}\ncubeDistance(hexA, hexB) {\n  const { q, r, s } = this.cubeSubstract(hexA, hexB);\n  return (Math.abs(q) + Math.abs(r) + Math.abs(s)) / 2;\n}\ncubeLinearInt(hexA, hexB, t) {\n  return this.Hex(this.linearInt(hexA.q, hexB.q, t), this.linearInt(hexA.r, hexB.r, t), this.linearInt(hexA.s, hexB.s, t));\n}\nlinearInt(a, b, t) {\n    return (a + (b - a) * t)\n}\nPoint(x, y) {\n     return {x: x, y: y}\n   }\n   Hex(q, r, s) {\n     return {q: q, r: r, s: s}\n   }\n   drawLine(canvasID, start, end, lineWidth, lineColor) {\n     const ctx = canvasID.getContext(\"2d\");\n     ctx.beginPath();\n     ctx.moveTo(start.x, start.y);\n     ctx.strokeStyle = lineColor;\n     ctx.lineWidth = lineWidth;\n     ctx.lineTo(end.x, end.y);\n     ctx.stroke();\n     ctx.closePath();\n   }\n\n   fillHex(canvasID, center, fillColor) {\n     let c0 = this.getHexCornerCoord(center, 0);\n     let c1 = this.getHexCornerCoord(center, 1);\n     let c2 = this.getHexCornerCoord(center, 2);\n     let c3 = this.getHexCornerCoord(center, 3);\n     let c4 = this.getHexCornerCoord(center, 4);\n     let c5 = this.getHexCornerCoord(center, 5);\n     const ctx = canvasID. getContext(\"2d\");\n     ctx.beginPath();\n     ctx.fillStyle = fillColor;\n     ctx.globalAlpha = 0.1;\n     ctx.moveTo(c0.x, c0.y);\n     ctx.lineTo(c1.x, c1.y);\n     ctx.lineTo(c2.x, c2.y);\n     ctx.lineTo(c3.x, c3.y);\n     ctx.lineTo(c4.x, c4.y);\n     ctx.lineTo(c5.x, c5.y);\n     ctx.closePath();\n     ctx.fill();\n   }\n   drawHexCoordinates(canvasID, center, h) {\n     const ctx = canvasID.getContext(\"2d\");\n     ctx.fillText(h.q, center.x+6, center.y);\n     ctx.fillText(h.r, center.x-3, center.y+15);\n     ctx.fillText(h.s, center.x-12, center.y);\n   }\ndrawNeighbors(h) {\n  for (let i = 0; i <= 5; i++) {\n    const { q, r, s} = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n    const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n    this.drawHex(this.canvasInteraction, this.Point(x, y), \"red\", 2);\n  }\n}\n\nhandleMouseMove(e) {\n     const { canvasWidth, canvasHeight } = this.state.canvasSize;\n     const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n     const { left, right, top, bottom } = this.state.canvasPosition;\n     var canvasPos = document.getElementById(\"canv7\");\n     let rect = canvasPos.getBoundingClientRect();\n     let offsetX = e.pageX - rect.left;\n     let offsetY = (e.pageY - (window.pageYOffset + rect.top));\n     const { q, r, s } = this.cubeRound(this.pixelToHex(this.Point(offsetX, offsetY)));\n     const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n     let playerPosition = this.state.playerPosition;\n     this.getDistanceLine(this.Hex(0,0,0), this.Hex(q,r,s));\n     /*this.getDistanceLine(this.Hex(0,0,0), this.Hex(q,r,s));*/\n     this.getPath(this.Hex(playerPosition.q, playerPosition.r, playerPosition.s), this.Hex(q,r,s));\n      if ((x >hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\nthis.setState({\n  currentHex: {q, r, s, x, y}\n})\n}\n   }\n\n   getPath(start, current) {\n  const { cameFrom } = this.state;\n  start = JSON.stringify(start);\n  current = JSON.stringify(current);\n  if(cameFrom[current] != undefined) {\n    var path = [current];\n    while (current != start) {\n      current = cameFrom[current];\n      path.push(current);\n    }\n    path = [].concat(path);\n    this.setState({\n      path: path\n    })\n  }\n}\n\ndrawPath() {\nlet path = this.state.path;\nfor (let i = 0; i <= path.length - 1; i++) {\n  const {q,r} = JSON.parse(path[i]);\n  const {x,y} = this.hexToPixel(this.Hex(q,r));\n  this.drawHex(this.canvasInteraction, this.Point(x,y), 1, \"black\", \"red\");\n}\n}\n\ndrawArrow(fromx, fromy, tox, toy){\n                var ctx = this.canvasView.getContext(\"2d\");\n                var headlen = 5;\n                var angle = Math.atan2(toy-fromy,tox-fromx);\n                ctx.beginPath();\n                ctx.moveTo(fromx, fromy);\n                ctx.lineTo(tox, toy);\n                ctx.strokeStyle = \"#cc0000\";\n                ctx.lineWidth = 3;\n                ctx.stroke();\n                ctx.beginPath();\n                ctx.moveTo(tox, toy);\n                ctx.globalAlpha = 0.3;\n                ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));\n                ctx.lineTo(tox-headlen*Math.cos(angle+Math.PI/7),toy-headlen*Math.sin(angle+Math.PI/7));\n                ctx.lineTo(tox, toy);\n                ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));\n                ctx.strokeStyle = \"#cc0000\";\n                ctx.lineWidth = 5;\n                ctx.stroke();\n                ctx.fillStyle = \"#cc0000\";\n                ctx.fill();\n            }\n\n            handleClick() {\n\nconst { currentHex, cameFrom } = this.state;\nconst { q,r,s } = currentHex;\nif(cameFrom[JSON.stringify(this.Hex(q,r,s))]) {\n  this.setState(\n    {playerPosition: this.Hex(q,r,s)},\n    this.breadthFirstSearchCallback = () => this.breadthFirstSearch(this.state.playerPosition)\n  )\n}\n   }\n\n   drawObstacles() {\n  this.state.obstacles.map((l) => {\n    const {q,r,s} = JSON.parse(l);\n    const {x,y} = this.hexToPixel(this.Hex(q,r,s));\n    this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"black\");\n  })\n}\n\nbreadthFirstSearch(playerPosition) {\nvar frontier = [playerPosition];\nvar cameFrom = {};\ncameFrom[JSON.stringify(playerPosition)] = JSON.stringify(playerPosition);\nwhile (frontier.length != 0) {\n  var current = frontier.shift();\n  let arr = this.getNeighbors(current);\n  arr.map((l) => {\n\n    if(!cameFrom.hasOwnProperty(JSON.stringify(l)) && this.state.hexPathMap.includes(JSON.stringify(l))) {\n      frontier.push(l);\n      cameFrom[JSON.stringify(l)] = JSON.stringify(current);\n    }\n  })\n\n}\ncameFrom = Object.assign({}, cameFrom);\nthis.setState({\n  cameFrom: cameFrom\n})\n}\n\n\n\n  resetSketch() {\n  window.location.reload();\n  }\n\n\nrender() {\n    return (\n      <div className=\"BFSExtra\">\n        <div className=\"title2\">\n        Breadth First Search\n        </div>\n        <div className=\"description2\">\n          <b id=\"bold\">How to use: </b>Click different areas of the board to see how BFS algorithm finds the shortest path!<br></br>\n\n          <b id=\"bold\">How it works:</b><br></br>\n        The shortest path is being calculated live by giving a distance value to every<br></br>\n        node on the board. The red arrows indicate the path that the algorithm is taking<br></br>\n        from node to node.<br></br>\n      *View the second board below to see how the shortest path is determined step by step.\n        </div>\n        <canvas id=\"canv8\" ref={canvasHex => this.canvasHex = canvasHex }> </canvas>\n        <canvas id=\"canv7\" ref={canvasCoordinates => this.canvasCoordinates = canvasCoordinates }> </canvas>\n        <canvas id=\"canv6\" ref={canvasView => this.canvasView = canvasView }> </canvas>\n        <canvas id=\"canv5\" ref={canvasInteraction => this.canvasInteraction = canvasInteraction} onMouseMove = {this.handleMouseMove} onClick={this.handleClick}> </canvas>\n\n    </div>\n    )\n\n  }\n\n}","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BubbleSort/BubbleSort.js",["111","112","113"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/QuickSort/QuickSort.js",["114","115","116","117"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Router.js",["118"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Navbar.js",["119"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/A*Star/A_star.js",["120"],"import React, { Component } from 'react';\nimport P5Wrapper from 'react-p5-wrapper';\n\nexport default class AStar extends Component {\n    sketch(p){\n\n        // Function to delete element from the array\n        function removeFromArray(arr, elt) {\n            // Could use indexOf here instead to be more efficient\n            for (let i = arr.length - 1; i >= 0; i--) {\n              if (arr[i] == elt) {\n                arr.splice(i, 1);\n              }\n            }\n          }\n          \n          // An educated guess of how far it is between two points\n          function heuristic(a, b) {\n            let d = p.dist(a.i, a.j, b.i, b.j);\n            // let d = abs(a.i - b.i) + abs(a.j - b.j);\n            return d;\n          }\n          \n          // How many columns and rows?\n          let cols = 50;\n          let rows = 50;\n          \n          // This will be the 2D array\n          let grid = new Array(cols);\n          \n          // Open and closed set\n          let openSet = [];\n          let closedSet = [];\n          \n          // Start and end\n          let start;\n          let end;\n          \n          // Width and height of each cell of grid\n          let w, h;\n          \n          // The road taken\n          let path = [];\n          \n            p.setup = () => {\n            p.createCanvas(800, 800);\n            console.log('A*');\n          \n            // Grid cell size\n            w = p.width / cols;\n            h = p.height / rows;\n          \n            // Making a 2D array\n            for (let i = 0; i < cols; i++) {\n              grid[i] = new Array(rows);\n            }\n          \n            for (let i = 0; i < cols; i++) {\n              for (let j = 0; j < rows; j++) {\n                grid[i][j] = new Spot(i, j);\n              }\n            }\n          \n            // All the neighbors\n            for (let i = 0; i < cols; i++) {\n              for (let j = 0; j < rows; j++) {\n                grid[i][j].addNeighbors(grid);\n              }\n            }\n          \n            // Start and end\n            start = grid[0][0];\n            end = grid[cols - 1][rows - 1];\n            start.wall = false;\n            end.wall = false;\n          \n            // openSet starts with beginning only\n            openSet.push(start);\n\n            let button = p.createButton(\"reset\");\n            button.mousePressed(resetSketch);\n            button.parent(\"resetAStar\");\n          }\n          function resetSketch() {\n            window.location.reload();\n        }\n          \n          p.draw = () => {\n            // Am I still searching?\n            if (openSet.length > 0) {\n              // Best next option\n              let winner = 0;\n              for (let i = 0; i < openSet.length; i++) {\n                if (openSet[i].f < openSet[winner].f) {\n                  winner = i;\n                }\n              }\n              let current = openSet[winner];\n          \n              // Did I finish?\n              if (current === end) {\n                p.noLoop();\n                console.log('DONE!');\n              }\n          \n              // Best option moves from openSet to closedSet\n              removeFromArray(openSet, current);\n              closedSet.push(current);\n          \n              // Check all the neighbors\n              let neighbors = current.neighbors;\n              for (let i = 0; i < neighbors.length; i++) {\n                let neighbor = neighbors[i];\n          \n                // Valid next spot?\n                if (!closedSet.includes(neighbor) && !neighbor.wall) {\n                  let tempG = current.g + heuristic(neighbor, current);\n          \n                  // Is this a better path than before?\n                  let newPath = false;\n                  if (openSet.includes(neighbor)) {\n                    if (tempG < neighbor.g) {\n                      neighbor.g = tempG;\n                      newPath = true;\n                    }\n                  } else {\n                    neighbor.g = tempG;\n                    newPath = true;\n                    openSet.push(neighbor);\n                  }\n          \n                  // Yes, it's a better path\n                  if (newPath) {\n                    neighbor.h = heuristic(neighbor, end);\n                    neighbor.f = neighbor.g + neighbor.h;\n                    neighbor.previous = current;\n                  }\n                }\n              }\n              // Uh oh, no solution\n            } else {\n              console.log('no solution');\n              p.noLoop();\n              return;\n            }\n          \n            // Draw current state of everything\n            p.background(255);\n          \n            for (let i = 0; i < cols; i++) {\n              for (let j = 0; j < rows; j++) {\n                grid[i][j].show();\n              }\n            }\n          \n            for (let i = 0; i < closedSet.length; i++) {\n              closedSet[i].show(p.color(255, 0, 0, 50));\n            }\n          \n            for (let i = 0; i < openSet.length; i++) {\n              openSet[i].show(p.color(0, 255, 0, 50));\n            }\n          \n            // Find the path by working backwards\n            path = [];\n            let temp = path;\n            path.push(temp);\n            while (temp.previous) {\n              path.push(temp.previous);\n              temp = temp.previous;\n            }\n          \n            // for (let i = 0; i < path.length; i++) {\n            // path[i].show(color(0, 0, 255));\n            //}\n          \n            // Drawing path as continuous line\n            p.noFill();\n            p.stroke(255, 0, 200);\n            p.strokeWeight(w / 2);\n            p.beginShape();\n            for (let i = 0; i < path.length; i++) {\n              p.vertex(path[i].i * w + w / 2, path[i].j * h + h / 2);\n            }\n            p.endShape();\n          }\n          // An object to describe a spot in the grid\n         function Spot(i, j) {\n              // Location\n              this.i = i;\n              this.j = j;\n            \n              // f, g, and h values for A*\n              this.f = 0;\n              this.g = 0;\n              this.h = 0;\n            \n              // Neighbors\n              this.neighbors = [];\n            \n              // Where did I come from?\n              this.previous = undefined;\n            \n              // Am I a wall?\n              this.wall = false;\n              if (p.random(1) < 0.4) {\n                this.wall = true;\n              }\n            \n              // Display me\n              this.show = function(col) {\n                if (this.wall) {\n                  p.fill(0);\n                  p.noStroke();\n                  p.ellipse(this.i * w + w / 2, this.j * h + h / 2, w / 2, h / 2);\n                } else if (col) {\n                  p.fill(col);\n                  p.rect(this.i * w, this.j * h, w, h);\n                }\n              };\n            \n              // Figure out who my neighbors are\n              this.addNeighbors = function(grid) {\n                var i = this.i;\n                var j = this.j;\n                if (i < cols - 1) {\n                  this.neighbors.push(grid[i + 1][j]);\n                }\n                if (i > 0) {\n                  this.neighbors.push(grid[i - 1][j]);\n                }\n                if (j < rows - 1) {\n                  this.neighbors.push(grid[i][j + 1]);\n                }\n                if (j > 0) {\n                  this.neighbors.push(grid[i][j - 1]);\n                }\n                if (i > 0 && j > 0) {\n                  this.neighbors.push(grid[i - 1][j - 1]);\n                }\n                if (i < cols - 1 && j > 0) {\n                  this.neighbors.push(grid[i + 1][j - 1]);\n                }\n                if (i > 0 && j < rows - 1) {\n                  this.neighbors.push(grid[i - 1][j + 1]);\n                }\n                if (i < cols - 1 && j < rows - 1) {\n                  this.neighbors.push(grid[i + 1][j + 1]);\n                }\n              };\n        }\n    }\n    render(){\n        return(\n            <section id='AStar'>\n                <div className='title5'>\n                    A* Algorithm\n                </div>\n                <div id=\"resetAStar\"></div>\n                <P5Wrapper sketch={this.sketch}></P5Wrapper>\n            </section>\n\n        )\n    }\n}\n","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Traveling_Salesperson/TravelingSalesperson.js",["121"],"import React, { Component } from 'react';\nimport P5Wrapper from 'react-p5-wrapper';\n\nexport default class TravelingSalesperson extends Component {\n    sketch(p){\n\n        let cities = [];\n        let totalCities = 12;\n\n        let popSize = 500;\n        let population = [];\n        let fitness = [];\n\n        let recordDistance = Infinity;\n        let bestEver;\n        let currentBest;\n\n        let statusP;\n\n        p.setup = () => {\n        p.createCanvas(800, 800);\n        let order = [];\n        for (let i = 0; i < totalCities; i++) {\n            let v = p.createVector(p.random(p.width), p.random(p.height / 2));\n            cities[i] = v;\n            order[i] = i;\n        }\n\n        for (let i = 0; i < popSize; i++) {\n            population[i] = p.shuffle(order);\n        }\n        statusP = p.createP('').style('font-size', '32pt');\n\n        let button = p.createButton(\"reset\");\n            button.mousePressed(resetSketch);\n            button.parent(\"resetTravelingSalesperson\");\n        }\n\n        function resetSketch() {\n            window.location.reload();\n        }\n\n        p.draw = () => {\n        p.background(0);\n\n        // GA\n        calculateFitness();\n        normalizeFitness();\n        nextGeneration();\n\n        p.stroke(255);\n        p.strokeWeight(4);\n        p.noFill();\n        p.beginShape();\n        for (let i = 0; i < bestEver.length; i++) {\n            let n = bestEver[i];\n            p.vertex(cities[n].x, cities[n].y);\n            p.ellipse(cities[n].x, cities[n].y, 16, 16);\n        }\n        p.endShape();\n\n        p.translate(0, p.height / 2);\n        p.stroke(255);\n        p.strokeWeight(4);\n        p.noFill();\n        p.beginShape();\n        for (let i = 0; i < currentBest.length; i++) {\n            let n = currentBest[i];\n            p.vertex(cities[n].x, cities[n].y);\n            p.ellipse(cities[n].x, cities[n].y, 16, 16);\n        }\n        p.endShape();\n        }\n\n        function swap(a, i, j) {\n        let temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n        }\n\n        function calcDistance(points, order) {\n        let sum = 0;\n        for (let i = 0; i < order.length - 1; i++) {\n            let cityAIndex = order[i];\n            let cityA = points[cityAIndex];\n            let cityBIndex = order[i + 1];\n            let cityB = points[cityBIndex];\n            let d = p.dist(cityA.x, cityA.y, cityB.x, cityB.y);\n            sum += d;\n        }\n        return sum;\n        }\n        function calculateFitness() {\n            let currentRecord = Infinity;\n            for (let i = 0; i < population.length; i++) {\n              let d = calcDistance(cities, population[i]);\n              if (d < recordDistance) {\n                recordDistance = d;\n                bestEver = population[i];\n              }\n              if (d < currentRecord) {\n                currentRecord = d;\n                currentBest = population[i];\n              }\n              fitness[i] = 1 / (p.pow(d, 8) + 1);\n            }\n          }\n          \n          function normalizeFitness() {\n            let sum = 0;\n            for (let i = 0; i < fitness.length; i++) {\n              sum += fitness[i];\n            }\n            for (let i = 0; i < fitness.length; i++) {\n              fitness[i] = fitness[i] / sum;\n            }\n          }\n          \n          function nextGeneration() {\n            let newPopulation = [];\n            for (let i = 0; i < population.length; i++) {\n              let orderA = pickOne(population, fitness);\n              let orderB = pickOne(population, fitness);\n              let order = crossOver(orderA, orderB);\n              mutate(order, 0.01);\n              newPopulation[i] = order;\n            }\n            population = newPopulation;\n          }\n          \n          function pickOne(list, prob) {\n            let index = 0;\n            let r = p.random(1);\n          \n            while (r > 0) {\n              r = r - prob[index];\n              index++;\n            }\n            index--;\n            return list[index].slice();\n          }\n          \n          function crossOver(orderA, orderB) {\n            let start = p.floor(p.random(orderA.length));\n            let end = p.floor(p.random(start + 1, orderA.length));\n            let neworder = orderA.slice(start, end);\n            for (let i = 0; i < orderB.length; i++) {\n              let city = orderB[i];\n              if (!neworder.includes(city)) {\n                neworder.push(city);\n              }\n            }\n            return neworder;\n          }\n          \n          function mutate(order, mutationRate) {\n            for (let i = 0; i < totalCities; i++) {\n              if (p.random(1) < mutationRate) {\n                let indexA = p.floor(p.random(order.length));\n                let indexB = (indexA + 1) % totalCities;\n                swap(order, indexA, indexB);\n              }\n            }\n        }\n    }\n    render() {\n        return(\n            <section id='geneticAlgo'>\n                <div className='title5'>\n                    Traveling Salesperson \n                    <br></br>with Genetic Algorithm\n                </div>\n                <div id=\"resetTravelingSalesperson\"></div>\n                \n                <P5Wrapper sketch={this.sketch}></P5Wrapper>\n            </section>\n        )\n    }\n}\n ","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/HomePage/HomePage.js",["122","123","124","125","126","127"],{"ruleId":"128","replacedBy":"129"},{"ruleId":"130","replacedBy":"131"},{"ruleId":"132","severity":1,"message":"133","line":5,"column":3,"nodeType":"134","messageId":"135","endLine":5,"endColumn":12},{"ruleId":"132","severity":1,"message":"136","line":6,"column":3,"nodeType":"134","messageId":"135","endLine":6,"endColumn":10},{"ruleId":"132","severity":1,"message":"137","line":7,"column":3,"nodeType":"134","messageId":"135","endLine":7,"endColumn":11},{"ruleId":"132","severity":1,"message":"138","line":8,"column":3,"nodeType":"134","messageId":"135","endLine":8,"endColumn":7},{"ruleId":"132","severity":1,"message":"139","line":9,"column":3,"nodeType":"134","messageId":"135","endLine":9,"endColumn":9},{"ruleId":"132","severity":1,"message":"140","line":10,"column":3,"nodeType":"134","messageId":"135","endLine":10,"endColumn":8},{"ruleId":"132","severity":1,"message":"141","line":11,"column":3,"nodeType":"134","messageId":"135","endLine":11,"endColumn":7},{"ruleId":"132","severity":1,"message":"142","line":12,"column":3,"nodeType":"134","messageId":"135","endLine":12,"endColumn":7},{"ruleId":"132","severity":1,"message":"143","line":14,"column":3,"nodeType":"134","messageId":"135","endLine":14,"endColumn":10},{"ruleId":"132","severity":1,"message":"144","line":107,"column":15,"nodeType":"134","messageId":"135","endLine":107,"endColumn":16},{"ruleId":"132","severity":1,"message":"145","line":107,"column":18,"nodeType":"134","messageId":"135","endLine":107,"endColumn":19},{"ruleId":"132","severity":1,"message":"146","line":107,"column":21,"nodeType":"134","messageId":"135","endLine":107,"endColumn":22},{"ruleId":"147","severity":1,"message":"148","line":122,"column":34,"nodeType":"149","messageId":"150","endLine":122,"endColumn":36},{"ruleId":"132","severity":1,"message":"146","line":136,"column":23,"nodeType":"134","messageId":"135","endLine":136,"endColumn":24},{"ruleId":"132","severity":1,"message":"151","line":388,"column":34,"nodeType":"134","messageId":"135","endLine":388,"endColumn":42},{"ruleId":"132","severity":1,"message":"152","line":388,"column":44,"nodeType":"134","messageId":"135","endLine":388,"endColumn":53},{"ruleId":"132","severity":1,"message":"153","line":404,"column":8,"nodeType":"134","messageId":"135","endLine":404,"endColumn":22},{"ruleId":"147","severity":1,"message":"148","line":427,"column":27,"nodeType":"149","messageId":"150","endLine":427,"endColumn":29},{"ruleId":"154","severity":1,"message":"155","line":442,"column":17,"nodeType":"156","messageId":"157","endLine":442,"endColumn":19},{"ruleId":"158","severity":1,"message":"159","line":450,"column":15,"nodeType":"149","messageId":"160","endLine":455,"endColumn":8},{"ruleId":"147","severity":1,"message":"148","line":450,"column":19,"nodeType":"149","messageId":"150","endLine":450,"endColumn":21},{"ruleId":"132","severity":1,"message":"161","line":1,"column":16,"nodeType":"134","messageId":"135","endLine":1,"endColumn":25},{"ruleId":"132","severity":1,"message":"144","line":116,"column":11,"nodeType":"134","messageId":"135","endLine":116,"endColumn":12},{"ruleId":"132","severity":1,"message":"145","line":116,"column":14,"nodeType":"134","messageId":"135","endLine":116,"endColumn":15},{"ruleId":"132","severity":1,"message":"146","line":116,"column":17,"nodeType":"134","messageId":"135","endLine":116,"endColumn":18},{"ruleId":"132","severity":1,"message":"162","line":116,"column":20,"nodeType":"134","messageId":"135","endLine":116,"endColumn":21},{"ruleId":"132","severity":1,"message":"163","line":116,"column":23,"nodeType":"134","messageId":"135","endLine":116,"endColumn":24},{"ruleId":"132","severity":1,"message":"146","line":129,"column":19,"nodeType":"134","messageId":"135","endLine":129,"endColumn":20},{"ruleId":"154","severity":1,"message":"155","line":153,"column":12,"nodeType":"156","messageId":"157","endLine":153,"endColumn":14},{"ruleId":"164","severity":1,"message":"165","line":321,"column":18,"nodeType":"166","messageId":"167","endLine":321,"endColumn":38,"fix":"168"},{"ruleId":"132","severity":1,"message":"151","line":350,"column":35,"nodeType":"134","messageId":"135","endLine":350,"endColumn":43},{"ruleId":"132","severity":1,"message":"152","line":350,"column":45,"nodeType":"134","messageId":"135","endLine":350,"endColumn":54},{"ruleId":"132","severity":1,"message":"169","line":351,"column":14,"nodeType":"134","messageId":"135","endLine":351,"endColumn":18},{"ruleId":"132","severity":1,"message":"170","line":351,"column":20,"nodeType":"134","messageId":"135","endLine":351,"endColumn":25},{"ruleId":"132","severity":1,"message":"171","line":351,"column":27,"nodeType":"134","messageId":"135","endLine":351,"endColumn":30},{"ruleId":"132","severity":1,"message":"172","line":351,"column":32,"nodeType":"134","messageId":"135","endLine":351,"endColumn":38},{"ruleId":"154","severity":1,"message":"173","line":373,"column":24,"nodeType":"156","messageId":"157","endLine":373,"endColumn":26},{"ruleId":"154","severity":1,"message":"173","line":375,"column":20,"nodeType":"156","messageId":"157","endLine":375,"endColumn":22},{"ruleId":"147","severity":1,"message":"148","line":432,"column":32,"nodeType":"149","messageId":"150","endLine":432,"endColumn":34},{"ruleId":"154","severity":1,"message":"173","line":443,"column":24,"nodeType":"156","messageId":"157","endLine":443,"endColumn":26},{"ruleId":"158","severity":1,"message":"159","line":446,"column":11,"nodeType":"149","messageId":"160","endLine":452,"endColumn":4},{"ruleId":"147","severity":1,"message":"148","line":446,"column":15,"nodeType":"149","messageId":"150","endLine":446,"endColumn":17},{"ruleId":"132","severity":1,"message":"174","line":3,"column":8,"nodeType":"134","messageId":"135","endLine":3,"endColumn":14},{"ruleId":"132","severity":1,"message":"175","line":11,"column":13,"nodeType":"134","messageId":"135","endLine":11,"endColumn":14},{"ruleId":"132","severity":1,"message":"176","line":12,"column":13,"nodeType":"134","messageId":"135","endLine":12,"endColumn":14},{"ruleId":"154","severity":1,"message":"173","line":92,"column":13,"nodeType":"156","messageId":"157","endLine":92,"endColumn":15},{"ruleId":"154","severity":1,"message":"155","line":105,"column":21,"nodeType":"156","messageId":"157","endLine":105,"endColumn":23},{"ruleId":"154","severity":1,"message":"155","line":107,"column":28,"nodeType":"156","messageId":"157","endLine":107,"endColumn":30},{"ruleId":"154","severity":1,"message":"155","line":109,"column":28,"nodeType":"156","messageId":"157","endLine":109,"endColumn":30},{"ruleId":"132","severity":1,"message":"177","line":2,"column":17,"nodeType":"134","messageId":"135","endLine":2,"endColumn":25},{"ruleId":"178","severity":1,"message":"179","line":11,"column":25,"nodeType":"180","endLine":11,"endColumn":100},{"ruleId":"154","severity":1,"message":"155","line":11,"column":26,"nodeType":"156","messageId":"157","endLine":11,"endColumn":28},{"ruleId":"132","severity":1,"message":"181","line":32,"column":9,"nodeType":"134","messageId":"135","endLine":32,"endColumn":16},{"ruleId":"178","severity":1,"message":"179","line":17,"column":17,"nodeType":"180","endLine":17,"endColumn":34},{"ruleId":"178","severity":1,"message":"179","line":21,"column":17,"nodeType":"180","endLine":21,"endColumn":39},{"ruleId":"178","severity":1,"message":"179","line":25,"column":17,"nodeType":"180","endLine":25,"endColumn":36},{"ruleId":"178","severity":1,"message":"179","line":29,"column":17,"nodeType":"180","endLine":29,"endColumn":36},{"ruleId":"178","severity":1,"message":"179","line":33,"column":17,"nodeType":"180","endLine":33,"endColumn":41},{"ruleId":"178","severity":1,"message":"179","line":37,"column":17,"nodeType":"180","endLine":37,"endColumn":36},"no-native-reassign",["182"],"no-negated-in-lhs",["183"],"no-unused-vars","'Container' is defined but never used.","Identifier","unusedVar","'Divider' is defined but never used.","'Dropdown' is defined but never used.","'Grid' is defined but never used.","'Header' is defined but never used.","'Image' is defined but never used.","'List' is defined but never used.","'Menu' is defined but never used.","'Segment' is defined but never used.","'q' is assigned a value but never used.","'r' is assigned a value but never used.","'s' is assigned a value but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","'vertDist' is assigned a value but never used.","'horizDist' is assigned a value but never used.","'playerPosition' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'cameFrom', 'cameFrom', 'current'.","unsafeRefs","'Component' is defined but never used.","'x' is assigned a value but never used.","'y' is assigned a value but never used.","no-whitespace-before-property","Unexpected whitespace before property getContext.","MemberExpression","unexpectedWhitespace",{"range":"184","text":"185"},"'left' is assigned a value but never used.","'right' is assigned a value but never used.","'top' is assigned a value but never used.","'bottom' is assigned a value but never used.","Expected '!==' and instead saw '!='.","'Button' is defined but never used.","'j' is assigned a value but never used.","'w' is assigned a value but never used.","'Redirect' is defined but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'statusP' is assigned a value but never used.","no-global-assign","no-unsafe-negation",[12189,12191],"."]