[{"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/index.js":"1","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/App.js":"2","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/reportWebVitals.js":"3","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/PathfindingVisualizer.js":"4","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/Node/Node.js":"5","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/dijkstra/djikstra.js":"6","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS.jsx":"7","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS2.js":"8","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BubbleSort/BubbleSort.js":"9","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/QuickSort/QuickSort.js":"10","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Router.js":"11","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Navbar.js":"12"},{"size":500,"mtime":1607018973582,"results":"13","hashOfConfig":"14"},{"size":988,"mtime":1607890628502,"results":"15","hashOfConfig":"14"},{"size":362,"mtime":1607018973582,"results":"16","hashOfConfig":"14"},{"size":6066,"mtime":1607735444050,"results":"17","hashOfConfig":"14"},{"size":689,"mtime":1607735611637,"results":"18","hashOfConfig":"14"},{"size":2464,"mtime":1607735320937,"results":"19","hashOfConfig":"14"},{"size":18033,"mtime":1607819990890,"results":"20","hashOfConfig":"14"},{"size":18030,"mtime":1607819997085,"results":"21","hashOfConfig":"14"},{"size":1415,"mtime":1607831825488,"results":"22","hashOfConfig":"14"},{"size":4244,"mtime":1607890774283,"results":"23","hashOfConfig":"14"},{"size":789,"mtime":1607890682922,"results":"24","hashOfConfig":"14"},{"size":561,"mtime":1607890553049,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"zofrmq",{"filePath":"29","messages":"30","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"28"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"28"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":1,"source":"45","usedDeprecatedRules":"28"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48","usedDeprecatedRules":"28"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"51","messages":"52","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/index.js",[],["55","56"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/App.js",["57","58","59","60","61","62"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/reportWebVitals.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/PathfindingVisualizer.js",["63","64","65","66","67","68","69","70","71"],"import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"../dijkstra/djikstra\";\nimport {\n  Container,\n  Divider,\n  Dropdown,\n  Grid,\n  Header,\n  Image,\n  List,\n  Menu,\n  Button,\n  Segment\n} from \"semantic-ui-react\";\n\n\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 10;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 40;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [],\n      mouseIsPressed: false\n    };\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({ grid });\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({ grid: newGrid, mouseIsPressed: true });\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({ grid: newGrid });\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 50 * i);\n    }\n  }\n\n  visualizeDijkstra() {\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  clearPath() {\n    this.setState({ grid: [] });\n    const grid = getInitialGrid();\n    this.setState({ grid });\n  }\n\n  resetSketch() {\n    window.location.reload();\n  }\n\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n\n    return (\n      <section id=\"dijkstraSec\">\n\n        <div id=\"dijkstraTitle\">\n  Dijkstra's Algorithm\n</div> <b></b>\n\n<div className=\"dijkstraDescription\">\n<b id=\"bold\">How to use: </b>Create walls by clicking and dragging over the grid.<br></br> Hit visualize\n  to see Dijkstra's Algorithm select the shortest path! <br></br>\n<b id=\"bold\">How it works: </b> The <b>start</b> node and <b>end</b> node are marked on left and right respectively.<br></br>\n  Find distance to all nodes from start, all distances=infinity except start node to begin <br></br>\n<b id=\"bold\">1.</b> Pick the closest node to visit, which is start node.\n  <b id=\"bold\">2.</b> Update neighboring nodes, set their distance to current distance + 1.<br></br>\n  <b id=\"bold\">3.</b> Mark start node visited. Select next closest node.\n  <b id=\"bold\">4.</b> Pick one of the 4 neighbors and repeat.<br></br><br></br>\n<b id=\"bold\">Note: </b>The most efficient way to keep track of the closest unvisited node is by using a Min Heap.<br></br>\n  Since the amount of nodes is so few here, we opt for using an array of unvisited nodes and<br></br>\n   sort the nodes with each pass. The nodes are animated in the order that they are visited.\n\n\n</div>\n\n          <Button\n              style={{ marginRight: 16 }}\n              onClick={() => this.clearPath()}\n            >\n              Clear Path\n            </Button>\n\n            <Button\n              color=\"blue\"\n              style={{ marginRight: 16 }}\n              onClick={() => this.visualizeDijkstra()}>\n              Visualize Algorithm\n            </Button>\n\n\n\n\n        <Button onClick={() => this.resetSketch()}>\n          Reset Board\n        </Button>\n\n        <div className=\"dijkstraGrid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isFinish, isStart, isWall } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </section>\n    );\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/PathfindingVisualizer/Node/Node.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/dijkstra/djikstra.js",[],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS.jsx",["72","73","74","75","76","77","78","79","80","81","82","83","84"],"import React, {Component} from 'react';\nimport {\n    Button\n  } from \"semantic-ui-react\";\n\n\nvar DUMMY_OBSTACLES = ['{\"q\":6,\"r\":9,\"s\":-15}', '{\"q\":7,\"r\":8,\"s\":-15}', '{\"q\":7,\"r\":7,\"s\":-14}', '{\"q\":8,\"r\":6,\"s\":-14}', '{\"q\":8,\"r\":5,\"s\":-13}', '{\"q\":9,\"r\":4,\"s\":-13}', '{\"q\":5,\"r\":9,\"s\":-14}',\n '{\"q\":4,\"r\":9,\"s\":-13}', '{\"q\":3,\"r\":9,\"s\":-12}', '{\"q\":2,\"r\":9,\"s\":-11}', '{\"q\":1,\"r\":9,\"s\":-10}', '{\"q\":0,\"r\":9,\"s\":-9}', '{\"q\":-1,\"r\":9,\"s\":-8}', '{\"q\":-2,\"r\":9,\"s\":-7}', '{\"q\":-3,\"r\":9,\"s\":-6}',\n  '{\"q\":-4,\"r\":9,\"s\":-5}', '{\"q\":-5,\"r\":9,\"s\":-4}', '{\"q\":-6,\"r\":9,\"s\":-3}', '{\"q\":-7,\"r\":9,\"s\":-2}', '{\"q\":-8,\"r\":9,\"s\":-1}', '{\"q\":-9,\"r\":9,\"s\":0}', '{\"q\":-11,\"r\":9,\"s\":2}', '{\"q\":-10,\"r\":9,\"s\":1}',\n   '{\"q\":-12,\"r\":9,\"s\":3}', '{\"q\":-13,\"r\":9,\"s\":4}', '{\"q\":-14,\"r\":9,\"s\":5}', '{\"q\":-15,\"r\":9,\"s\":6}', '{\"q\":-15,\"r\":8,\"s\":7}', '{\"q\":-14,\"r\":7,\"s\":7}', '{\"q\":-14,\"r\":6,\"s\":8}', '{\"q\":-13,\"r\":5,\"s\":8}',\n    '{\"q\":-13,\"r\":4,\"s\":9}', '{\"q\":-12,\"r\":3,\"s\":9}', '{\"q\":-12,\"r\":2,\"s\":10}', '{\"q\":-11,\"r\":1,\"s\":10}', '{\"q\":-11,\"r\":0,\"s\":11}', '{\"q\":-10,\"r\":-1,\"s\":11}', '{\"q\":-10,\"r\":-2,\"s\":12}',\n     '{\"q\":-9,\"r\":-3,\"s\":12}', '{\"q\":-9,\"r\":-4,\"s\":13}', '{\"q\":-8,\"r\":-5,\"s\":13}', '{\"q\":-8,\"r\":-6,\"s\":14}', '{\"q\":-7,\"r\":-7,\"s\":14}', '{\"q\":-7,\"r\":-8,\"s\":15}', '{\"q\":-6,\"r\":-9,\"s\":15}',\n      '{\"q\":-5,\"r\":-9,\"s\":14}', '{\"q\":-4,\"r\":-9,\"s\":13}', '{\"q\":-3,\"r\":-9,\"s\":12}', '{\"q\":-2,\"r\":-9,\"s\":11}', '{\"q\":-1,\"r\":-9,\"s\":10}', '{\"q\":0,\"r\":-9,\"s\":9}', '{\"q\":1,\"r\":-9,\"s\":8}', '{\"q\":2,\"r\":-9,\"s\":7}',\n       '{\"q\":3,\"r\":-9,\"s\":6}', '{\"q\":4,\"r\":-9,\"s\":5}', '{\"q\":5,\"r\":-9,\"s\":4}', '{\"q\":6,\"r\":-9,\"s\":3}', '{\"q\":7,\"r\":-9,\"s\":2}', '{\"q\":8,\"r\":-9,\"s\":1}', '{\"q\":9,\"r\":-9,\"s\":0}', '{\"q\":10,\"r\":-9,\"s\":-1}',\n        '{\"q\":11,\"r\":-9,\"s\":-2}', '{\"q\":12,\"r\":-9,\"s\":-3}', '{\"q\":13,\"r\":-9,\"s\":-4}', '{\"q\":14,\"r\":-9,\"s\":-5}', '{\"q\":15,\"r\":-9,\"s\":-6}', '{\"q\":15,\"r\":-8,\"s\":-7}', '{\"q\":14,\"r\":-7,\"s\":-7}',\n         '{\"q\":14,\"r\":-6,\"s\":-8}', '{\"q\":13,\"r\":-5,\"s\":-8}', '{\"q\":13,\"r\":-4,\"s\":-9}', '{\"q\":12,\"r\":-3,\"s\":-9}', '{\"q\":12,\"r\":-2,\"s\":-10}', '{\"q\":11,\"r\":-1,\"s\":-10}', '{\"q\":11,\"r\":0,\"s\":-11}',\n          '{\"q\":10,\"r\":1,\"s\":-11}', '{\"q\":10,\"r\":2,\"s\":-12}', '{\"q\":9,\"r\":3,\"s\":-12}', '{\"q\":-2, \"r\":-8, \"s\":10}', '{\"q\": -3, \"r\": -7, \"s\": 10}', '{\"q\": -4, \"r\": -6, \"s\": 10}', '{\"q\": -5, \"r\": -5, \"s\": 10}',\n          '{\"q\": -6, \"r\": -4, \"s\": 10}', '{\"q\": -7, \"r\": -4, \"s\": 11}', '{\"q\": 4, \"r\": -7, \"s\": 3}', '{\"q\": 3, \"r\": -6, \"s\": 3}', '{\"q\": 2, \"r\": -5, \"s\": 3}',\n    '{\"q\": 1, \"r\": -4, \"s\": 3}',\n    '{\"q\": 2, \"r\": -4, \"s\": 2}',\n    '{\"q\": 3, \"r\": -4, \"s\": 1}',\n    '{\"q\": 4, \"r\": -4, \"s\": 0}',\n    '{\"q\": 9, \"r\": -3, \"s\": -6}',\n    '{\"q\": 10, \"r\": -3, \"s\": -7}',\n    '{\"q\": 8, \"r\": -2, \"s\": -6}',\n    '{\"q\": 7, \"r\": -2, \"s\": -5}',\n    '{\"q\": 4, \"r\": -2, \"s\": -2}',\n    '{\"q\": 4, \"r\": -1, \"s\": -3}',\n    '{\"q\": 4, \"r\": 0, \"s\": -4}',\n    '{\"q\": 4, \"r\": 1, \"s\": -5}',\n    '{\"q\": 3, \"r\": 2, \"s\": -5}',\n    '{\"q\": 2, \"r\": 3, \"s\": -5}',\n    '{\"q\": 1, \"r\": 4, \"s\": -5}',\n    '{\"q\": -0, \"r\": 5, \"s\": -5}',\n    '{\"q\": -1, \"r\": 6, \"s\": -5}',\n    '{\"q\": -2, \"r\": 7, \"s\": -5}',\n    '{\"q\": 4, \"r\": 5, \"s\": -9}',\n    '{\"q\": 4, \"r\": 6, \"s\": -10}',\n    '{\"q\": 5, \"r\": 6, \"s\": -11}',\n    '{\"q\": 5, \"r\": 7, \"s\": -12}',\n    '{\"q\": -5, \"r\": 7, \"s\": -2}',\n    '{\"q\": -5, \"r\": 8, \"s\": -3}',\n    '{\"q\": -5, \"r\": 6, \"s\": -1}',\n    '{\"q\": -5, \"r\": 5, \"s\": 0}',\n    '{\"q\": -4, \"r\": 4, \"s\": -0}',\n    '{\"q\": -3, \"r\": 3, \"s\": -0}',\n    '{\"q\": -5, \"r\": 3, \"s\": 2}',\n    '{\"q\": -6, \"r\": 4, \"s\": 2}',\n    '{\"q\": -4, \"r\": 2, \"s\": 2}',\n    '{\"q\": -4, \"r\": 1, \"s\": 3}',\n    '{\"q\": -7, \"r\": 4, \"s\": 3}',\n    '{\"q\": -8, \"r\": 4, \"s\": 4}',\n    '{\"q\": -9, \"r\": 4, \"s\": 5}',\n    '{\"q\": -10, \"r\": 4, \"s\": 6}',\n    '{\"q\": -11, \"r\": 4, \"s\": 7}',\n    '{\"q\": -12, \"r\": 4, \"s\": 8}',\n    '{\"q\": -6, \"r\": 1, \"s\": 5}',\n    '{\"q\": -6, \"r\": 0, \"s\": 6}',\n    '{\"q\": -6, \"r\": -1, \"s\": 7}',\n    '{\"q\": -6, \"r\": -2, \"s\": 8}',\n    '{\"q\": -2, \"r\": -1, \"s\": 3}',\n    '{\"q\": -2, \"r\": -2, \"s\": 4}']\n\n\n\n\nexport default class BreadthFirstSearch extends Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.handleClick = this.handleClick.bind(this);\n    this.handleExpandClick = this.handleExpandClick.bind(this);\n\n    this.state = {\n      hexSize: 20,\n      //position of the very middle hexagon (changes the numbers seen in hexagons)\n      //decreasing y moves hexagon(0,0,0) upwards, increasing x moves hexagon(0,0,0) to the right\n      hexOrigin: { x: 400, y: 300 },\n      currentHex: {q: 0, r: 0, s: 0, x: 0, y: 0},\n      playerPosition: {q: 0, r: 0, s: 0, x: 400, y: 300},\n      obstacles: DUMMY_OBSTACLES,\n      frontier: [],\n      //storing hexagons starting from playerPosition\n      cameFrom: {}\n    }\n  }\n  componentWillMount(){\n    let hexParametres = this.getHexParametres();\n    this.setState({\n      canvasSize: { canvasWidth: 800, canvasHeight: 600 },\n      hexParametres: hexParametres\n    })\n  }\n\n  componentDidMount(){\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    this.canvasHex.width = canvasWidth;\n    this.canvasHex.height = canvasHeight;\n    this.canvasInteraction.width = canvasWidth;\n    this.canvasInteraction.height = canvasHeight;\n    this.canvasView.width = canvasWidth;\n    this.canvasView.height = canvasHeight;\n    this.getCanvasPosition(this.canvasInteraction);\n    this.drawHex(this.canvasInteraction, this.Point(this.state.playerPosition.x, this.state.playerPosition.y), 1, \"grey\", \"red\", 0.2);\n    this.drawHexes();\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if(nextState.currentHex !== this.state.currentHex) {\n      const { q, r, s, x, y } = nextState.currentHex;\n      const { canvasWidth, canvasHeight } = this.state.canvasSize;\n      const ctx = this.canvasInteraction.getContext(\"2d\");\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n      let currentDistanceLine = nextState.currentDistanceLine;\n\n      for (let i = 0; i <= currentDistanceLine.length - 2; i++) {\n        if(i === 0) {\n          this.drawHex(this.canvasInteraction, this.Point(currentDistanceLine[i].x, currentDistanceLine[i].y), 1, \"black\", \"red\");\n        }else {\n          this.drawHex(this.canvasInteraction, this.Point(currentDistanceLine[i].x, currentDistanceLine[i].y), 1, \"black\", \"grey\");\n        }\n\n      }\n      nextState.obstacles.map((l)=>{\n        const { q, r, s } = JSON.parse(l);\n        const { x, y } = this.hexToPixel(this.Hex(q, r, s))\n        this.drawHex(this.canvasInteraction, this.Point(x, y), 1, \"black\", \"black\");\n\n      })\n      this.drawHex(this.canvasInteraction, this.Point(x, y), 1, \"black\", \"grey\");\n      return true;\n    }\n    if(nextState.cameFrom !== this.state.cameFrom) {\n      const { canvasWidth, canvasHeight } = this.state.canvasSize;\n      const ctx = this.canvasView.getContext(\"2d\");\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n      for(let l in nextState.cameFrom) {\n        const { q, r, s } = JSON.parse(l);\n        const { x, y } = this.hexToPixel(this.Hex(q, r));\n        this.drawHex(this.canvasView, this.Point(x, y), 1, \"black\", \"green\", 0.1);\n      }\n      return true;\n    }\n\n    return false;\n  }\n\n\n  drawHexes() {\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n    //calculate how many columns are on the left side\n    //hexOrigin is distance from coorindate x = 0 to hex0(middle hexagon)\n    const hexOrigin = this.state.hexOrigin;\n    //dividing the distance from the left side of border(x=0) by\n    //the width of a hexagon to calculate how many hexagons fit on left\n    let qLeftSide = Math.round(hexOrigin.x/horizDist);\n    //calculate how many hexagons will fit on the right\n    let qRightSide = Math.round((canvasWidth - hexOrigin.x)/horizDist);\n    let rTopSide = Math.round(hexOrigin.y/vertDist);\n    let rBottomSide = Math.round((canvasHeight - hexOrigin.y)/vertDist);\n    var p = 0;\n    //screenshot 1 - populates hexigons vertically (populates POSITIVE rows)\n    for(let r = 0; r <= rBottomSide; r++) {\n      if(r%2 === 0 && r !== 0) {\n        p++;\n      }\n      //populates hexigons horizontally in upper half (populates POSITIVE columns)\n      for(let q = -qLeftSide; q <= qRightSide; q++) {\n          const { x, y } = this.hexToPixel(this.Hex(q-p, r));\n          if((x > hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n            this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n            //passing in canvas and position of each hex(row, column)\n\n          }\n      }\n    }\n    var n = 0;\n    //screenshot 1 - populates hexigons vertically (populates NEGATIVE rows)\n    for(let r = -1; r >= -rTopSide; r--) {\n      if(r%2 !== 0) {\n        n++;\n      }\n      //populates hexigons horizontally in lower half (populates NEGATIVE columns)\n      for(let q = -qLeftSide; q <= qRightSide; q++) {\n          //adding integers to hexToPixel arguments shifts hexagons right\n          const { x, y } = this.hexToPixel(this.Hex(q+n, r));\n          if((x > hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n            this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n\n          }\n      }\n    }\n  }\n\n  //builds the individual hex shape\n  drawHex(canvasID, center, lineWidth, lineColor, fillColor) {\n    for(let i = 0; i <=5; i++) {\n      let start = this.getHexCornerCoord(center, i);\n      let end = this.getHexCornerCoord(center, i + 1);\n\n      this.fillHex(canvasID, center, fillColor);\n      this.drawLine(canvasID, start, end, lineWidth, lineColor);\n\n    }\n  }\n\n  //get the coordinates of the corner to draw the hex\n    getHexCornerCoord(center, i) {\n      var angle_deg = 60 * i + 30;\n      var angle_rad = Math.PI / 180 * angle_deg;\n      let x = center.x + this.state.hexSize * Math.cos(angle_rad);\n      let y = center.y + this.state.hexSize * Math.sin(angle_rad);\n      return this.Point(x, y);\n    }\n\n    Hex(q, r, s) {\n      return {q: q, r: r, s: s}\n    }\n\n    Point(x, y) {\n      return {x: x, y: y}\n    }\n\n//draws the line that shapes the hex\n  drawLine(canvasID, start, end, lineWidth, lineColor) {\n    const ctx = canvasID.getContext(\"2d\");\n    ctx.beginPath();\n    ctx.moveTo(start.x, start.y);\n    ctx.strokeStyle = lineColor;\n    ctx.lineWidth = lineWidth;\n    ctx.lineTo(end.x, end.y);\n    ctx.stroke();\n    ctx.closePath();\n  }\n\n  fillHex(canvasID, center, fillColor) {\n    let c0 = this.getHexCornerCoord(center, 0);\n    let c1 = this.getHexCornerCoord(center, 1);\n    let c2 = this.getHexCornerCoord(center, 2);\n    let c3 = this.getHexCornerCoord(center, 3);\n    let c4 = this.getHexCornerCoord(center, 4);\n    let c5 = this.getHexCornerCoord(center, 5);\n    const ctx = canvasID.getContext(\"2d\");\n    ctx.beginPath();\n    ctx.fillStyle = fillColor;\n    ctx.globalAlpha = 0.1;\n    ctx.moveTo(c0.x, c0.y);\n    ctx.lineTo(c1.x, c1.y);\n    ctx.lineTo(c2.x, c2.y);\n    ctx.lineTo(c3.x, c3.y);\n    ctx.lineTo(c4.x, c4.y);\n    ctx.lineTo(c5.x, c5.y);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n//prints the coordinates inside of the hexagons\n  drawHexCoordinates(canvasID, center, h) {\n    const ctx = canvasID.getContext(\"2d\");\n    ctx.fillText(h.q, center.x+6, center.y);\n    ctx.fillText(h.r, center.x-3, center.y+15);\n    ctx.fillText(h.s, center.x-12, center.y);\n  }\n\n\n\n  getHexParametres() {\n    let hexHeight = this.state.hexSize * 2;\n    let hexWidth = Math.sqrt(3)/2 * hexHeight;\n    //vertical distance between hexigons in each row\n    let vertDist = hexHeight * 3/4;\n    let horizDist = hexWidth;\n    return { hexWidth, hexHeight, vertDist, horizDist }\n  }\n\n  hexToPixel(h) {\n    //can change where the bundle of hexes originates on the whole grid\n    let hexOrigin = this.state.hexOrigin;\n    let x = this.state.hexSize * Math.sqrt(3) * (h.q + h.r/2) + hexOrigin.x;\n    let y = this.state.hexSize * 3/2 * h.r + hexOrigin.y;\n    return this.Point(x, y)\n  }\n\n  pixelToHex(p) {\n    let size = this.state.hexSize;\n    let origin = this.state.hexOrigin;\n    let q = ((p.x - origin.x) * Math.sqrt(3)/3 - (p.y - origin.y) / 3) / size\n    let r = (p.y - origin.y) * 2/3 / size\n    return this.Hex(q, r, -q - r);\n  }\n\n  getDistanceLine(hexA, hexB) {\n    let dist = this.cubeDistance(hexA, hexB);\n    var arr = [];\n    for(let i = 0; i <= dist; i++) {\n     let center = this.hexToPixel(this.cubeRound(this.cubeLinearInt(hexA, hexB, 1.0 / dist * i)));\n     arr = [].concat(arr, center);\n    }\n    this.setState({\n      currentDistanceLine: arr\n    })\n  }\n\n\n\n  cubeDirection(direction) {\n    const cubeDirections = [this.Hex(1, 0, -1), this.Hex(1, -1, 0), this.Hex(0, -1, 1),\n    this.Hex(-1, 0, 1), this.Hex(-1, 1, 0), this.Hex(0, 1, -1)];\n    return cubeDirections[direction];\n  }\n\n  cubeLinearInt(hexA, hexB, t) {\n    return this.Hex(this.linearInt(hexA.q, hexB.q, t), this.linearInt(hexA.r, hexB.r, t),\n    this.linearInt(hexA.s, hexB.s, t));\n  }\n\n  linearInt(a, b, t) {\n    return (a + (b - a) * t)\n  }\n\n  cubeAdd(a, b) {\n    return this.Hex(a.q + b.q, a.r + b.r, a.s + b.s);\n  }\n\n  cubeSubstract(hexA, hexB) {\n    return this.Hex(hexA.q - hexB.q, hexA.r - hexB.r, hexA.s - hexB.s);\n  }\n\n  getCubeNeighbor(h, direction) {\n    return this.cubeAdd(h, this.cubeDirection(direction));\n  }\n\n  getNeighbors(h) {\n    var arr = [];\n    for(let i = 0; i <=5; i++) {\n      const { q, r, s } = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n      arr.push(this.Hex(q, r, s));\n    }\n    return arr;\n  }\n\n\n\n  cubeRound(cube) {\n    var rx = Math.round(cube.q)\n    var ry = Math.round(cube.r)\n    var rz = Math.round(cube.s)\n    var x_diff = Math.abs(rx - cube.q)\n    var y_diff = Math.abs(ry - cube.r)\n    var z_diff = Math.abs(rz - cube.s)\n    if(x_diff > y_diff && x_diff > z_diff) {\n      rx = -ry-rz\n    }\n    else if(y_diff > z_diff) {\n      ry = -rx-rz\n    }\n    else{\n      rz = -rx-ry\n    }\n    return this.Hex(rx, ry, rz)\n  }\n\n\n\n  cubeDistance(hexA, hexB) {\n    const { q, r, s } = this.cubeSubstract(hexA, hexB);\n    return (Math.abs(q) + Math.abs(r) + Math.abs(s)) / 2;\n  }\n\n\n  drawNeighbors(h) {\n    for(let i = 0; i <= 5; i++) {\n      const { q, r, s } = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n      const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n      this.drawHex(this.canvasInteraction, this.Point(x, y), \"red\", 2);\n    }\n  }\n\n\n    getCanvasPosition(canvasID) {\n      let rect = canvasID.getBoundingClientRect();\n      this.setState({\n         canvasPosition: { left:rect.left, right: rect.right, top: rect.top, bottom: rect.bottom }\n      })\n    }\n\n  handleMouseMove(e) {\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n    //const { left, right, top, bottom } = this.state.canvasPosition;\n    //changing the number at the end affects result exponentially\n    var canvasPos = document.getElementById(\"canv3\");\n    let rect = canvasPos.getBoundingClientRect();\n    let offsetX = e.pageX - rect.left;\n    let offsetY = (e.pageY - (window.pageYOffset + rect.top));\n\n\n\n\n\n\n    const { q, r, s } = this.cubeRound(this.pixelToHex(this.Point(offsetX, offsetY)));\n    const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n\n   let playerPosition = this.state.playerPosition;\n\n\n    this.getDistanceLine(this.Hex(0,0,0), this.Hex(q,r,s));\n\n    if((x > hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n      this.setState({\n        currentHex: {q, r, s, x, y}\n      })\n    }\n\n  }\n\n  handleClick() {\n    this.addObstacles();\n  }\n\n  addObstacles() {\n    const { q, r, s } = this.state.currentHex;\n    let obstacles = this.state.obstacles;\n    if(!obstacles.includes(JSON.stringify(this.Hex(q, r, s)))) {\n      obstacles = [].concat(obstacles, JSON.stringify(this.Hex(q, r, s)))\n    } else {\n      obstacles.map((l,i) => {\n        if(l === JSON.stringify(this.Hex(q, r, s))) {\n          obstacles = obstacles.slice(0, i).concat(obstacles.slice(i+1));\n        }\n      })\n    }\n    console.log({\"q\":q, \"r\":r, \"s\":s})\n    this.setState({\n      obstacles: obstacles\n    })\n  }\n\n  handleExpandClick() {\n    var frontier = this.state.frontier;\n    var cameFrom = this.state.cameFrom;\n    if(frontier == 0) {\n      frontier.push(this.Hex(0,0,0));\n      cameFrom[JSON.stringify(this.Hex(0,0,0))] = JSON.stringify(null);\n    }\n    let n = 0;\n    while(n < 1) {\n      var current = frontier.shift();\n      let arr = this.getNeighbors(current);\n      arr.map((l) => {\n        if(!cameFrom.hasOwnProperty(JSON.stringify(l)) && !this.state.obstacles.includes(JSON.stringify(l))) {\n          frontier.push(l);\n          cameFrom[JSON.stringify(l)] = JSON.stringify(current);\n        }\n      })\n      n++\n    }\n    cameFrom = Object.assign({}, cameFrom);\n    this.setState({\n      cameFrom: cameFrom\n    })\n  }\n\n  resetSketch() {\n  window.location.reload();\n  }\n\n\nrender() {\n    return (\n      <section id=\"BFS\">\n        <div className=\"description25\">\n        <b id=\"bold\">How to use:</b> Hit expand to see Breadth First Search carried out starting\n          from the middle node.\n        </div>\n\n          <button\n              className=\"reset1\"\n              onClick={ this.resetSketch }\n              style= {{ textAlign: \"center\" }}\n            >\n              Reset\n            </button>\n\n            <button\n              className=\"expandButton1\"\n              color=\"blue\"\n              style={{textAlign: \"center\"}}\n              onClick={this.handleExpandClick}>\n              Expand\n            </button>\n\n            <br></br>\n        <canvas id=\"canv4\" ref={canvasHex => this.canvasHex = canvasHex }> </canvas>\n        <canvas id=\"canv3\" ref={canvasCoordinates => this.canvasCoordinates = canvasCoordinates }> </canvas>\n        <canvas id=\"canv2\" ref={canvasView => this.canvasView = canvasView }> </canvas>\n        <canvas id=\"canv1\" ref={canvasInteraction => this.canvasInteraction = canvasInteraction} onMouseMove = {this.handleMouseMove} onClick = {this.handleClick}> </canvas>\n    </section>\n    )\n\n  }\n\n}","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BFS/BFS2.js",["85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105"],"import React, {Component} from 'react';\n\nvar DUMMY_OBSTACLES = ['{\"q\":4,\"r\":-2,\"s\":-2}', '{\"q\":4,\"r\":-1,\"s\":-3}', '{\"q\":4,\"r\":0,\"s\":-4}', '{\"q\":4,\"r\":1,\"s\":-5}', '{\"q\":3,\"r\":2,\"s\":-5}', '{\"q\":2,\"r\":3,\"s\":-5}', '{\"q\":1,\"r\":4,\"s\":-5}', '{\"q\":0,\"r\":5,\"s\":-5}', '{\"q\":-1,\"r\":6,\"s\":-5}', '{\"q\":-2,\"r\":7,\"s\":-5}', '{\"q\":4,\"r\":-4,\"s\":0}', '{\"q\":3,\"r\":-4,\"s\":1}', '{\"q\":2,\"r\":-4,\"s\":2}', '{\"q\":1,\"r\":-4,\"s\":3}', '{\"q\":2,\"r\":-5,\"s\":3}', '{\"q\":3,\"r\":-6,\"s\":3}', '{\"q\":4,\"r\":-7,\"s\":3}', '{\"q\":5,\"r\":-9,\"s\":4}', '{\"q\":6,\"r\":-9,\"s\":3}', '{\"q\":7,\"r\":-9,\"s\":2}', '{\"q\":8,\"r\":-9,\"s\":1}', '{\"q\":9,\"r\":-9,\"s\":0}', '{\"q\":10,\"r\":-9,\"s\":-1}', '{\"q\":11,\"r\":-9,\"s\":-2}', '{\"q\":12,\"r\":-9,\"s\":-3}', '{\"q\":13,\"r\":-9,\"s\":-4}', '{\"q\":14,\"r\":-9,\"s\":-5}', '{\"q\":15,\"r\":-9,\"s\":-6}', '{\"q\":15,\"r\":-8,\"s\":-7}', '{\"q\":14,\"r\":-7,\"s\":-7}', '{\"q\":14,\"r\":-6,\"s\":-8}', '{\"q\":13,\"r\":-5,\"s\":-8}', '{\"q\":13,\"r\":-4,\"s\":-9}', '{\"q\":12,\"r\":-3,\"s\":-9}', '{\"q\":12,\"r\":-2,\"s\":-10}', '{\"q\":11,\"r\":-1,\"s\":-10}', '{\"q\":11,\"r\":0,\"s\":-11}', '{\"q\":10,\"r\":1,\"s\":-11}', '{\"q\":10,\"r\":2,\"s\":-12}', '{\"q\":9,\"r\":3,\"s\":-12}', '{\"q\":9,\"r\":4,\"s\":-13}', '{\"q\":8,\"r\":5,\"s\":-13}', '{\"q\":8,\"r\":6,\"s\":-14}', '{\"q\":7,\"r\":7,\"s\":-14}', '{\"q\":7,\"r\":8,\"s\":-15}', '{\"q\":6,\"r\":9,\"s\":-15}', '{\"q\":5,\"r\":9,\"s\":-14}', '{\"q\":4,\"r\":9,\"s\":-13}', '{\"q\":3,\"r\":9,\"s\":-12}', '{\"q\":2,\"r\":9,\"s\":-11}', '{\"q\":1,\"r\":9,\"s\":-10}', '{\"q\":0,\"r\":9,\"s\":-9}', '{\"q\":-1,\"r\":9,\"s\":-8}', '{\"q\":-2,\"r\":9,\"s\":-7}', '{\"q\":-3,\"r\":9,\"s\":-6}', '{\"q\":-4,\"r\":9,\"s\":-5}', '{\"q\":-5,\"r\":9,\"s\":-4}', '{\"q\":-5,\"r\":8,\"s\":-3}', '{\"q\":-5,\"r\":7,\"s\":-2}', '{\"q\":-5,\"r\":6,\"s\":-1}', '{\"q\":-5,\"r\":5,\"s\":0}', '{\"q\":-4,\"r\":4,\"s\":0}', '{\"q\":-3,\"r\":3,\"s\":0}', '{\"q\":-2,\"r\":-1,\"s\":3}', '{\"q\":-2,\"r\":-2,\"s\":4}', '{\"q\":-4,\"r\":1,\"s\":3}', '{\"q\":-4,\"r\":2,\"s\":2}', '{\"q\":-5,\"r\":3,\"s\":2}', '{\"q\":-7,\"r\":4,\"s\":3}', '{\"q\":-6,\"r\":4,\"s\":2}', '{\"q\":-8,\"r\":4,\"s\":4}', '{\"q\":-9,\"r\":4,\"s\":5}', '{\"q\":-10,\"r\":4,\"s\":6}', '{\"q\":-11,\"r\":4,\"s\":7}', '{\"q\":-12,\"r\":4,\"s\":8}', '{\"q\":-12,\"r\":2,\"s\":10}', '{\"q\":-12,\"r\":3,\"s\":9}', '{\"q\":-13,\"r\":4,\"s\":9}', '{\"q\":-13,\"r\":5,\"s\":8}', '{\"q\":-14,\"r\":6,\"s\":8}', '{\"q\":-14,\"r\":7,\"s\":7}', '{\"q\":-15,\"r\":8,\"s\":7}', '{\"q\":-15,\"r\":9,\"s\":6}', '{\"q\":-14,\"r\":9,\"s\":5}', '{\"q\":-13,\"r\":9,\"s\":4}', '{\"q\":-12,\"r\":9,\"s\":3}', '{\"q\":-11,\"r\":9,\"s\":2}', '{\"q\":-10,\"r\":9,\"s\":1}', '{\"q\":-9,\"r\":9,\"s\":0}', '{\"q\":-8,\"r\":9,\"s\":-1}', '{\"q\":-7,\"r\":9,\"s\":-2}', '{\"q\":-6,\"r\":9,\"s\":-3}', '{\"q\":-11,\"r\":1,\"s\":10}', '{\"q\":-11,\"r\":0,\"s\":11}', '{\"q\":-10,\"r\":-1,\"s\":11}', '{\"q\":-10,\"r\":-2,\"s\":12}', '{\"q\":-9,\"r\":-3,\"s\":12}', '{\"q\":-9,\"r\":-4,\"s\":13}', '{\"q\":-8,\"r\":-5,\"s\":13}', '{\"q\":-8,\"r\":-6,\"s\":14}', '{\"q\":-7,\"r\":-7,\"s\":14}', '{\"q\":-7,\"r\":-8,\"s\":15}', '{\"q\":-6,\"r\":-9,\"s\":15}', '{\"q\":-5,\"r\":-9,\"s\":14}', '{\"q\":-4,\"r\":-9,\"s\":13}', '{\"q\":-3,\"r\":-9,\"s\":12}', '{\"q\":-2,\"r\":-9,\"s\":11}', '{\"q\":-1,\"r\":-9,\"s\":10}', '{\"q\":0,\"r\":-9,\"s\":9}', '{\"q\":1,\"r\":-9,\"s\":8}', '{\"q\":2,\"r\":-9,\"s\":7}', '{\"q\":3,\"r\":-9,\"s\":6}', '{\"q\":4,\"r\":-9,\"s\":5}', '{\"q\":-2,\"r\":-8,\"s\":10}', '{\"q\":-3,\"r\":-7,\"s\":10}', '{\"q\":-4,\"r\":-6,\"s\":10}', '{\"q\":-5,\"r\":-5,\"s\":10}', '{\"q\":-6,\"r\":-4,\"s\":10}', '{\"q\":-7,\"r\":-4,\"s\":11}', '{\"q\":-6,\"r\":-2,\"s\":8}', '{\"q\":-6,\"r\":-1,\"s\":7}', '{\"q\":-6,\"r\":0,\"s\":6}', '{\"q\":-6,\"r\":1,\"s\":5}', '{\"q\":7,\"r\":-2,\"s\":-5}', '{\"q\":8,\"r\":-2,\"s\":-6}', '{\"q\":9,\"r\":-3,\"s\":-6}', '{\"q\":10,\"r\":-3,\"s\":-7}', '{\"q\":4,\"r\":5,\"s\":-9}', '{\"q\":4,\"r\":6,\"s\":-10}', '{\"q\":5,\"r\":6,\"s\":-11}', '{\"q\":5,\"r\":7,\"s\":-12}']\n\n\nexport default class BFSExtra extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.handleClick = this.handleClick.bind(this);\n    //possibly but this.breadthFirstSearch = this.breadthfirstsearch.bind(this)\n\n\n    this.state = {\n      hexSize: 20,\n      //position of the very middle hexagon (changes the numbers seen in hexagons)\n      //decreasing y moves hexagon(0,0,0) upwards, increasing x moves hexagon(0,0,0) to the right\n      hexOrigin: { x: 400, y: 300 },\n      currentHex: {q: 0, r: 0, s: 0, x: 0, y: 0},\n      playerPosition: { q: 0, r: 0, s: 0 },\n      obstacles: DUMMY_OBSTACLES,\n      cameFrom: {},\n      hexPathMap: [],\n      path: []\n    }\n  }\n  componentWillMount(){\n    let hexParametres =  this.getHexParametres();\n    this.setState({\n      canvasSize: { canvasWidth: 800, canvasHeight: 600 },\n      hexParametres: hexParametres\n    })\n  }\n\n  componentDidMount(){\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n    this.canvasHex.width = canvasWidth;\n    this.canvasHex.height = canvasHeight;\n    this.canvasInteraction.width = canvasWidth;\n    this.canvasInteraction.height = canvasHeight;\n    this.canvasView.width = canvasWidth;\n    this.canvasView.height = canvasHeight;\n    this.getCanvasPosition(this.canvasInteraction);\n    this.drawHex(this.canvasInteraction, this.Point(this.state.playerPosition.x, this.state.playerPosition.y), 1, \"grey\", \"red\", 0.2);\n    this.drawHexes();\n    this.drawObstacles();\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if(nextState.currentHex !== this.state.currentHex) {\n  const { q, r, s, x, y } = nextState.currentHex;\n  const { canvasWidth, canvasHeight } = this.state.canvasSize;\n  const ctx = this.canvasInteraction.getContext(\"2d\");\n  ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n  /*this.drawNeighbors(this.Hex(q, r, s));*/\n  this.drawPath();\n  return true;\n}\n  if(nextState.cameFrom !== this.state.cameFrom) {\n  const { canvasWidth, canvasHeight } = this.state.canvasSize;\n  const ctx = this.canvasView.getContext(\"2d\");\n  ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n  for (let l in nextState.cameFrom) {\n    const { q, r, s } = JSON.parse(l);\n    const { x, y } = this.hexToPixel(this.Hex(q, r));\n    this.drawHex(this.canvasView, this.Point(x, y), 1, \"black\", \"green\", 0.1);\n    var from = JSON.parse(nextState.cameFrom[l]);\n    var fromCoord = this.hexToPixel(this.Hex(from.q, from.r));\n    this.drawArrow(fromCoord.x, fromCoord.y, x, y);\n  }\n  return true;\n  }\n  return false;\n  }\n\n\n  drawHexes() {\n    const { canvasWidth, canvasHeight } = this.state.canvasSize;\n  const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n  const hexOrigin = this.state.hexOrigin;\n  let qLeftSide = Math.round(hexOrigin.x/horizDist);\n  let qRightSide = Math.round((canvasWidth - hexOrigin.x)/horizDist);\n  let rTopSide = Math.round(hexOrigin.y/vertDist);\n  let rBottomSide = Math.round((canvasHeight - hexOrigin.y)/vertDist);\n  var hexPathMap = [];\n  var p = 0;\n  for (let r = 0; r <= rBottomSide; r++) {\n    if(r%2 == 0 && r !==0) {\n      p++;\n    }\n    for (let q = -qLeftSide; q <= qRightSide; q++) {\n        const { x, y } = this.hexToPixel(this.Hex(q-p, r));\n        if ((x >hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n          this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n          /*this.drawHexCoordinates(this.canvasHex, this.Point(x,y), this.Hex(q-p, r, -(q - p) - r));*/\n          var bottomH = JSON.stringify(this.Hex(q-p, r, -(q - p) - r));\n          if(!this.state.obstacles.includes(bottomH)) {\n            hexPathMap.push(bottomH);\n          }\n        }\n    }\n  }\nvar n = 0;\n  for (let r = -1; r >= -rTopSide; r--) {\n    if(r%2 !== 0) {\n      n++;\n    }\n    for (let q = -qLeftSide; q <= qRightSide; q++) {\n        const { x, y } = this.hexToPixel(this.Hex(q+n, r));\n          if ((x >hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\n        this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"grey\");\n        /*this.drawHexCoordinates(this.canvasHex, this.Point(x,y), this.Hex(q+n, r, - (q + n) - r));*/\n        var topH = JSON.stringify(this.Hex(q+n, r, - (q + n) - r));\n        if(!this.state.obstacles.includes(topH)) {\n          hexPathMap.push(topH);\n        }\n      }\n    }\n  }\n  hexPathMap = [].concat(hexPathMap);\n  this.setState(\n    {hexPathMap: hexPathMap},\n    this.breadthFirstSearchCallback = () => this.breadthFirstSearch(this.state.playerPosition)\n  )\n  }\n\n  //builds the individual hex shape\n  drawHex(canvasID, center, lineWidth, lineColor, fillColor) {\n  for (let i = 0; i <= 5; i++) {\n    let start = this.getHexCornerCoord(center, i);\n    let end = this.getHexCornerCoord(center, i + 1);\n    this.fillHex(canvasID, center, fillColor);\n    this.drawLine(canvasID, start, end, lineWidth, lineColor);\n  }\n}\n\n  //get the coordinates of the corner to draw the hex\n  getHexCornerCoord(center, i) {\n   let angle_deg = 60 * i   + 30;\n   let angle_rad = Math.PI / 180 * angle_deg;\n   let x = center.x + this.state.hexSize * Math.cos(angle_rad);\n  let y = center.y + this.state.hexSize * Math.sin(angle_rad);\n  return this.Point(x, y);\n }\n\n getHexParametres() {\n  let hexHeight = this.state.hexSize * 2;\n  let hexWidth = Math.sqrt(3)/2 * hexHeight;\n  let vertDist = hexHeight * 3/4;\n  let horizDist = hexWidth;\n  return { hexWidth, hexHeight, vertDist, horizDist }\n}\n\ngetCanvasPosition(canvasID) {\n  let rect = canvasID.getBoundingClientRect();\n  this.setState({\n    canvasPosition: { left:rect.left, right: rect.right, top: rect.top, bottom: rect.bottom }\n  })\n}\n   hexToPixel(h) {\n     let hexOrigin = this.state.hexOrigin;\n     let x = this.state.hexSize * Math.sqrt(3) * (h.q + h.r/2) + hexOrigin.x;\n     let y = this.state.hexSize * 3/2 * h.r + hexOrigin.y;\n     return this.Point(x, y)\n   }\n   pixelToHex(p) {\n     let size = this.state.hexSize;\n     let origin = this.state.hexOrigin;\n     let q = ((p.x - origin.x) * Math.sqrt(3)/3 - (p.y - origin.y) / 3) / size\n     let r = (p.y - origin.y) * 2/3 / size\n     return this.Hex(q, r, - q - r);\n   }\ncubeDirection(direction) {\n  const cubeDirections = [this.Hex(1, 0, -1), this.Hex(1, -1, 0), this.Hex(0, -1, 1),\n                          this.Hex(-1, 0, 1), this.Hex(-1, 1, 0), this.Hex(0, 1, -1)];\nreturn cubeDirections[direction];\n}\ncubeAdd(a, b) {\n  return this.Hex(a.q + b.q, a.r + b.r, a.s + b.s);\n}\ncubeSubstract(hexA, hexB) {\n  return this.Hex(hexA.q - hexB.q, hexA.r - hexB.r, hexA.s - hexB.s);\n}\ngetCubeNeighbor(h, direction) {\n  return this.cubeAdd(h, this.cubeDirection(direction));\n}\ngetNeighbors(h) {\n  var arr = [];\n  for (let i = 0; i <= 5; i++) {\n    const { q, r, s } = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n    arr.push(this.Hex(q, r, s));\n  }\n  return arr;\n}\n   cubeRound(cube) {\n     var rx = Math.round(cube.q)\n     var ry = Math.round(cube.r)\n     var rz = Math.round(cube.s)\n     var x_diff = Math.abs(rx - cube.q)\n     var y_diff = Math.abs(ry - cube.r)\n     var z_diff = Math.abs(rz - cube.s)\n     if (x_diff > y_diff && x_diff > z_diff) {\n       rx = -ry-rz;\n     } else if (y_diff > z_diff) {\n          ry = -rx-rz\n     } else {\n          rz = -rx-ry\n     }\n     return this.Hex(rx, ry, rz)\n   }\ngetDistanceLine(hexA, hexB) {\n  let dist = this.cubeDistance(hexA, hexB);\n  var arr = [];\n  for (let i = 0; i <= dist; i++) {\n  let center = this.hexToPixel(this.cubeRound(this.cubeLinearInt(hexA, hexB, 1.0 / dist * i)));\n  arr = [].concat(arr, center);\n  }\n  this.setState({\n    currentDistanceLine: arr\n  })\n}\ncubeDistance(hexA, hexB) {\n  const { q, r, s } = this.cubeSubstract(hexA, hexB);\n  return (Math.abs(q) + Math.abs(r) + Math.abs(s)) / 2;\n}\ncubeLinearInt(hexA, hexB, t) {\n  return this.Hex(this.linearInt(hexA.q, hexB.q, t), this.linearInt(hexA.r, hexB.r, t), this.linearInt(hexA.s, hexB.s, t));\n}\nlinearInt(a, b, t) {\n    return (a + (b - a) * t)\n}\nPoint(x, y) {\n     return {x: x, y: y}\n   }\n   Hex(q, r, s) {\n     return {q: q, r: r, s: s}\n   }\n   drawLine(canvasID, start, end, lineWidth, lineColor) {\n     const ctx = canvasID.getContext(\"2d\");\n     ctx.beginPath();\n     ctx.moveTo(start.x, start.y);\n     ctx.strokeStyle = lineColor;\n     ctx.lineWidth = lineWidth;\n     ctx.lineTo(end.x, end.y);\n     ctx.stroke();\n     ctx.closePath();\n   }\n\n   fillHex(canvasID, center, fillColor) {\n     let c0 = this.getHexCornerCoord(center, 0);\n     let c1 = this.getHexCornerCoord(center, 1);\n     let c2 = this.getHexCornerCoord(center, 2);\n     let c3 = this.getHexCornerCoord(center, 3);\n     let c4 = this.getHexCornerCoord(center, 4);\n     let c5 = this.getHexCornerCoord(center, 5);\n     const ctx = canvasID. getContext(\"2d\");\n     ctx.beginPath();\n     ctx.fillStyle = fillColor;\n     ctx.globalAlpha = 0.1;\n     ctx.moveTo(c0.x, c0.y);\n     ctx.lineTo(c1.x, c1.y);\n     ctx.lineTo(c2.x, c2.y);\n     ctx.lineTo(c3.x, c3.y);\n     ctx.lineTo(c4.x, c4.y);\n     ctx.lineTo(c5.x, c5.y);\n     ctx.closePath();\n     ctx.fill();\n   }\n   drawHexCoordinates(canvasID, center, h) {\n     const ctx = canvasID.getContext(\"2d\");\n     ctx.fillText(h.q, center.x+6, center.y);\n     ctx.fillText(h.r, center.x-3, center.y+15);\n     ctx.fillText(h.s, center.x-12, center.y);\n   }\ndrawNeighbors(h) {\n  for (let i = 0; i <= 5; i++) {\n    const { q, r, s} = this.getCubeNeighbor(this.Hex(h.q, h.r, h.s), i);\n    const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n    this.drawHex(this.canvasInteraction, this.Point(x, y), \"red\", 2);\n  }\n}\n\nhandleMouseMove(e) {\n     const { canvasWidth, canvasHeight } = this.state.canvasSize;\n     const { hexWidth, hexHeight, vertDist, horizDist } = this.state.hexParametres;\n     const { left, right, top, bottom } = this.state.canvasPosition;\n     var canvasPos = document.getElementById(\"canv7\");\n     let rect = canvasPos.getBoundingClientRect();\n     let offsetX = e.pageX - rect.left;\n     let offsetY = (e.pageY - (window.pageYOffset + rect.top));\n     const { q, r, s } = this.cubeRound(this.pixelToHex(this.Point(offsetX, offsetY)));\n     const { x, y } = this.hexToPixel(this.Hex(q, r, s));\n     let playerPosition = this.state.playerPosition;\n     this.getDistanceLine(this.Hex(0,0,0), this.Hex(q,r,s));\n     /*this.getDistanceLine(this.Hex(0,0,0), this.Hex(q,r,s));*/\n     this.getPath(this.Hex(playerPosition.q, playerPosition.r, playerPosition.s), this.Hex(q,r,s));\n      if ((x >hexWidth/2 && x < canvasWidth - hexWidth/2) && (y > hexHeight/2 && y < canvasHeight - hexHeight/2)) {\nthis.setState({\n  currentHex: {q, r, s, x, y}\n})\n}\n   }\n\n   getPath(start, current) {\n  const { cameFrom } = this.state;\n  start = JSON.stringify(start);\n  current = JSON.stringify(current);\n  if(cameFrom[current] != undefined) {\n    var path = [current];\n    while (current != start) {\n      current = cameFrom[current];\n      path.push(current);\n    }\n    path = [].concat(path);\n    this.setState({\n      path: path\n    })\n  }\n}\n\ndrawPath() {\nlet path = this.state.path;\nfor (let i = 0; i <= path.length - 1; i++) {\n  const {q,r} = JSON.parse(path[i]);\n  const {x,y} = this.hexToPixel(this.Hex(q,r));\n  this.drawHex(this.canvasInteraction, this.Point(x,y), 1, \"black\", \"red\");\n}\n}\n\ndrawArrow(fromx, fromy, tox, toy){\n                var ctx = this.canvasView.getContext(\"2d\");\n                var headlen = 5;\n                var angle = Math.atan2(toy-fromy,tox-fromx);\n                ctx.beginPath();\n                ctx.moveTo(fromx, fromy);\n                ctx.lineTo(tox, toy);\n                ctx.strokeStyle = \"#cc0000\";\n                ctx.lineWidth = 3;\n                ctx.stroke();\n                ctx.beginPath();\n                ctx.moveTo(tox, toy);\n                ctx.globalAlpha = 0.3;\n                ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));\n                ctx.lineTo(tox-headlen*Math.cos(angle+Math.PI/7),toy-headlen*Math.sin(angle+Math.PI/7));\n                ctx.lineTo(tox, toy);\n                ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/7),toy-headlen*Math.sin(angle-Math.PI/7));\n                ctx.strokeStyle = \"#cc0000\";\n                ctx.lineWidth = 5;\n                ctx.stroke();\n                ctx.fillStyle = \"#cc0000\";\n                ctx.fill();\n            }\n\n            handleClick() {\n\nconst { currentHex, cameFrom } = this.state;\nconst { q,r,s } = currentHex;\nif(cameFrom[JSON.stringify(this.Hex(q,r,s))]) {\n  this.setState(\n    {playerPosition: this.Hex(q,r,s)},\n    this.breadthFirstSearchCallback = () => this.breadthFirstSearch(this.state.playerPosition)\n  )\n}\n   }\n\n   drawObstacles() {\n  this.state.obstacles.map((l) => {\n    const {q,r,s} = JSON.parse(l);\n    const {x,y} = this.hexToPixel(this.Hex(q,r,s));\n    this.drawHex(this.canvasHex, this.Point(x,y), 1, \"black\", \"black\");\n  })\n}\n\nbreadthFirstSearch(playerPosition) {\nvar frontier = [playerPosition];\nvar cameFrom = {};\ncameFrom[JSON.stringify(playerPosition)] = JSON.stringify(playerPosition);\nwhile (frontier.length != 0) {\n  var current = frontier.shift();\n  let arr = this.getNeighbors(current);\n  arr.map((l) => {\n\n    if(!cameFrom.hasOwnProperty(JSON.stringify(l)) && this.state.hexPathMap.includes(JSON.stringify(l))) {\n      frontier.push(l);\n      cameFrom[JSON.stringify(l)] = JSON.stringify(current);\n    }\n  })\n\n}\ncameFrom = Object.assign({}, cameFrom);\nthis.setState({\n  cameFrom: cameFrom\n})\n}\n\n\n\n  resetSketch() {\n  window.location.reload();\n  }\n\n\nrender() {\n    return (\n      <div className=\"BFSExtra\">\n        <div className=\"title2\">\n        Breadth First Search\n        </div>\n        <div className=\"description2\">\n          <b id=\"bold\">How to use: </b>Click different areas of the board to see how BFS algorithm finds the shortest path!<br></br>\n\n          <b id=\"bold\">How it works:</b><br></br>\n        The shortest path is being calculated live by giving a distance value to every<br></br>\n        node on the board. The red arrows indicate the path that the algorithm is taking<br></br>\n        from node to node.<br></br>\n      *View the second board below to see how the shortest path is determined step by step.\n        </div>\n        <canvas id=\"canv8\" ref={canvasHex => this.canvasHex = canvasHex }> </canvas>\n        <canvas id=\"canv7\" ref={canvasCoordinates => this.canvasCoordinates = canvasCoordinates }> </canvas>\n        <canvas id=\"canv6\" ref={canvasView => this.canvasView = canvasView }> </canvas>\n        <canvas id=\"canv5\" ref={canvasInteraction => this.canvasInteraction = canvasInteraction} onMouseMove = {this.handleMouseMove} onClick={this.handleClick}> </canvas>\n\n    </div>\n    )\n\n  }\n\n}","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/BubbleSort/BubbleSort.js",["106","107","108"],"import React, {Component} from 'react';\nimport P5Wrapper from 'react-p5-wrapper';\nimport Button from 'react-p5-wrapper';\n\n\nexport default class BubbleSort extends Component {\n  sketch(p){\n    let values = [];\n\nlet i = 0;\nlet j = 0;\nlet w = 50;\n\n\np.setup = () => {\n  p.createCanvas(900, 600);\n  values = new Array(p.width);\n  for (let i = 0; i < values.length; i++) {\n    values[i] = p.random(p.height);\n    //values[i] = noise(i/100.0)*height;\n  }\n  var button = p.createButton(\"reset\");\n  button.mousePressed(resetSketch);\n  button.parent(\"resetQSort\");\n}\n\nfunction resetSketch() {\n  window.location.reload();\n}\n\np.draw = () => {\n  p.background(0);\n\n  if (i < values.length) {\n    for (let j = 0; j < values.length - i - 1; j++) {\n      let a = values[j];\n      let b = values[j + 1];\n      if (a > b) {\n        swap(values, j, j + 1);\n      }\n    }\n  } else {\n    console.log(\"finished\");\n    p.noLoop();\n  }\n  i++;\n  for (let i = 0; i < values.length; i++) {\n    p.stroke(255);\n    p.line(i, p.height, i, p.height - values[i]);\n  }\n}\n\n\nfunction swap(arr, a, b) {\n  let temp = arr[a];\n  arr[a] = arr[b];\n  arr[b] = temp;\n}\n  }\n\n  render() {\n\n    return (\n      <section id=\"QSort\">\n\n        <div className=\"title4\">\n  Bubble Sort\n</div>\n\n<div className=\"description4\">\n  <b> Need to make description :) </b>\n</div>\n<div id=\"resetQSort\"></div>\n<P5Wrapper sketch={this.sketch}></P5Wrapper>\n\n\n\n</section>\n);\n  }\n\n\n\n}","/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/QuickSort/QuickSort.js",["109","110","111","112"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Router.js",["113"],"/Users/tappy/Byte/AlgoSeeker/algo-seeker/src/components/Navbar/Navbar.js",[],{"ruleId":"114","replacedBy":"115"},{"ruleId":"116","replacedBy":"117"},{"ruleId":"118","severity":1,"message":"119","line":3,"column":25,"nodeType":"120","messageId":"121","endLine":3,"endColumn":29},{"ruleId":"118","severity":1,"message":"122","line":4,"column":8,"nodeType":"120","messageId":"121","endLine":4,"endColumn":29},{"ruleId":"118","severity":1,"message":"123","line":5,"column":8,"nodeType":"120","messageId":"121","endLine":5,"endColumn":11},{"ruleId":"118","severity":1,"message":"124","line":6,"column":8,"nodeType":"120","messageId":"121","endLine":6,"endColumn":12},{"ruleId":"118","severity":1,"message":"125","line":7,"column":8,"nodeType":"120","messageId":"121","endLine":7,"endColumn":17},{"ruleId":"118","severity":1,"message":"126","line":8,"column":8,"nodeType":"120","messageId":"121","endLine":8,"endColumn":18},{"ruleId":"118","severity":1,"message":"127","line":5,"column":3,"nodeType":"120","messageId":"121","endLine":5,"endColumn":12},{"ruleId":"118","severity":1,"message":"128","line":6,"column":3,"nodeType":"120","messageId":"121","endLine":6,"endColumn":10},{"ruleId":"118","severity":1,"message":"129","line":7,"column":3,"nodeType":"120","messageId":"121","endLine":7,"endColumn":11},{"ruleId":"118","severity":1,"message":"130","line":8,"column":3,"nodeType":"120","messageId":"121","endLine":8,"endColumn":7},{"ruleId":"118","severity":1,"message":"131","line":9,"column":3,"nodeType":"120","messageId":"121","endLine":9,"endColumn":9},{"ruleId":"118","severity":1,"message":"132","line":10,"column":3,"nodeType":"120","messageId":"121","endLine":10,"endColumn":8},{"ruleId":"118","severity":1,"message":"133","line":11,"column":3,"nodeType":"120","messageId":"121","endLine":11,"endColumn":7},{"ruleId":"118","severity":1,"message":"134","line":12,"column":3,"nodeType":"120","messageId":"121","endLine":12,"endColumn":7},{"ruleId":"118","severity":1,"message":"135","line":14,"column":3,"nodeType":"120","messageId":"121","endLine":14,"endColumn":10},{"ruleId":"118","severity":1,"message":"136","line":3,"column":5,"nodeType":"120","messageId":"121","endLine":3,"endColumn":11},{"ruleId":"118","severity":1,"message":"137","line":110,"column":15,"nodeType":"120","messageId":"121","endLine":110,"endColumn":16},{"ruleId":"118","severity":1,"message":"138","line":110,"column":18,"nodeType":"120","messageId":"121","endLine":110,"endColumn":19},{"ruleId":"118","severity":1,"message":"139","line":110,"column":21,"nodeType":"120","messageId":"121","endLine":110,"endColumn":22},{"ruleId":"140","severity":1,"message":"141","line":125,"column":34,"nodeType":"142","messageId":"143","endLine":125,"endColumn":36},{"ruleId":"118","severity":1,"message":"139","line":139,"column":23,"nodeType":"120","messageId":"121","endLine":139,"endColumn":24},{"ruleId":"118","severity":1,"message":"144","line":391,"column":34,"nodeType":"120","messageId":"121","endLine":391,"endColumn":42},{"ruleId":"118","severity":1,"message":"145","line":391,"column":44,"nodeType":"120","messageId":"121","endLine":391,"endColumn":53},{"ruleId":"118","severity":1,"message":"146","line":407,"column":8,"nodeType":"120","messageId":"121","endLine":407,"endColumn":22},{"ruleId":"140","severity":1,"message":"141","line":430,"column":27,"nodeType":"142","messageId":"143","endLine":430,"endColumn":29},{"ruleId":"147","severity":1,"message":"148","line":445,"column":17,"nodeType":"149","messageId":"150","endLine":445,"endColumn":19},{"ruleId":"151","severity":1,"message":"152","line":453,"column":15,"nodeType":"142","messageId":"153","endLine":458,"endColumn":8},{"ruleId":"140","severity":1,"message":"141","line":453,"column":19,"nodeType":"142","messageId":"143","endLine":453,"endColumn":21},{"ruleId":"118","severity":1,"message":"154","line":1,"column":16,"nodeType":"120","messageId":"121","endLine":1,"endColumn":25},{"ruleId":"118","severity":1,"message":"137","line":51,"column":11,"nodeType":"120","messageId":"121","endLine":51,"endColumn":12},{"ruleId":"118","severity":1,"message":"138","line":51,"column":14,"nodeType":"120","messageId":"121","endLine":51,"endColumn":15},{"ruleId":"118","severity":1,"message":"139","line":51,"column":17,"nodeType":"120","messageId":"121","endLine":51,"endColumn":18},{"ruleId":"118","severity":1,"message":"155","line":51,"column":20,"nodeType":"120","messageId":"121","endLine":51,"endColumn":21},{"ruleId":"118","severity":1,"message":"156","line":51,"column":23,"nodeType":"120","messageId":"121","endLine":51,"endColumn":24},{"ruleId":"118","severity":1,"message":"139","line":64,"column":19,"nodeType":"120","messageId":"121","endLine":64,"endColumn":20},{"ruleId":"147","severity":1,"message":"148","line":88,"column":12,"nodeType":"149","messageId":"150","endLine":88,"endColumn":14},{"ruleId":"157","severity":1,"message":"158","line":256,"column":18,"nodeType":"159","messageId":"160","endLine":256,"endColumn":38,"fix":"161"},{"ruleId":"118","severity":1,"message":"144","line":285,"column":35,"nodeType":"120","messageId":"121","endLine":285,"endColumn":43},{"ruleId":"118","severity":1,"message":"145","line":285,"column":45,"nodeType":"120","messageId":"121","endLine":285,"endColumn":54},{"ruleId":"118","severity":1,"message":"162","line":286,"column":14,"nodeType":"120","messageId":"121","endLine":286,"endColumn":18},{"ruleId":"118","severity":1,"message":"163","line":286,"column":20,"nodeType":"120","messageId":"121","endLine":286,"endColumn":25},{"ruleId":"118","severity":1,"message":"164","line":286,"column":27,"nodeType":"120","messageId":"121","endLine":286,"endColumn":30},{"ruleId":"118","severity":1,"message":"165","line":286,"column":32,"nodeType":"120","messageId":"121","endLine":286,"endColumn":38},{"ruleId":"147","severity":1,"message":"166","line":308,"column":24,"nodeType":"149","messageId":"150","endLine":308,"endColumn":26},{"ruleId":"147","severity":1,"message":"166","line":310,"column":20,"nodeType":"149","messageId":"150","endLine":310,"endColumn":22},{"ruleId":"140","severity":1,"message":"141","line":367,"column":32,"nodeType":"142","messageId":"143","endLine":367,"endColumn":34},{"ruleId":"147","severity":1,"message":"166","line":378,"column":24,"nodeType":"149","messageId":"150","endLine":378,"endColumn":26},{"ruleId":"151","severity":1,"message":"152","line":381,"column":11,"nodeType":"142","messageId":"153","endLine":387,"endColumn":4},{"ruleId":"140","severity":1,"message":"141","line":381,"column":15,"nodeType":"142","messageId":"143","endLine":381,"endColumn":17},{"ruleId":"118","severity":1,"message":"136","line":3,"column":8,"nodeType":"120","messageId":"121","endLine":3,"endColumn":14},{"ruleId":"118","severity":1,"message":"167","line":11,"column":5,"nodeType":"120","messageId":"121","endLine":11,"endColumn":6},{"ruleId":"118","severity":1,"message":"168","line":12,"column":5,"nodeType":"120","messageId":"121","endLine":12,"endColumn":6},{"ruleId":"147","severity":1,"message":"166","line":92,"column":13,"nodeType":"149","messageId":"150","endLine":92,"endColumn":15},{"ruleId":"147","severity":1,"message":"148","line":105,"column":21,"nodeType":"149","messageId":"150","endLine":105,"endColumn":23},{"ruleId":"147","severity":1,"message":"148","line":107,"column":28,"nodeType":"149","messageId":"150","endLine":107,"endColumn":30},{"ruleId":"147","severity":1,"message":"148","line":109,"column":28,"nodeType":"149","messageId":"150","endLine":109,"endColumn":30},{"ruleId":"118","severity":1,"message":"169","line":2,"column":10,"nodeType":"120","messageId":"121","endLine":2,"endColumn":23},"no-native-reassign",["170"],"no-negated-in-lhs",["171"],"no-unused-vars","'Link' is defined but never used.","Identifier","unusedVar","'PathfindingVisualizer' is defined but never used.","'BFS' is defined but never used.","'BFS2' is defined but never used.","'QuickSort' is defined but never used.","'BubbleSort' is defined but never used.","'Container' is defined but never used.","'Divider' is defined but never used.","'Dropdown' is defined but never used.","'Grid' is defined but never used.","'Header' is defined but never used.","'Image' is defined but never used.","'List' is defined but never used.","'Menu' is defined but never used.","'Segment' is defined but never used.","'Button' is defined but never used.","'q' is assigned a value but never used.","'r' is assigned a value but never used.","'s' is assigned a value but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","'vertDist' is assigned a value but never used.","'horizDist' is assigned a value but never used.","'playerPosition' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'cameFrom', 'cameFrom', 'current'.","unsafeRefs","'Component' is defined but never used.","'x' is assigned a value but never used.","'y' is assigned a value but never used.","no-whitespace-before-property","Unexpected whitespace before property getContext.","MemberExpression","unexpectedWhitespace",{"range":"172","text":"173"},"'left' is assigned a value but never used.","'right' is assigned a value but never used.","'top' is assigned a value but never used.","'bottom' is assigned a value but never used.","Expected '!==' and instead saw '!='.","'j' is assigned a value but never used.","'w' is assigned a value but never used.","'BrowserRouter' is defined but never used.","no-global-assign","no-unsafe-negation",[12124,12126],"."]